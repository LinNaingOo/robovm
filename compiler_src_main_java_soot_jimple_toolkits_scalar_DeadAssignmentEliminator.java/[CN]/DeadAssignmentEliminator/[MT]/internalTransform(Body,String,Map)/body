{
  boolean eliminateOnlyStackLocals=PhaseOptions.getBoolean(options,"only-stack-locals");
  if (Options.v().verbose())   G.v().out.println("[" + b.getMethod().getName() + "] Eliminating dead code...");
  if (Options.v().time())   Timers.v().deadCodeTimer.start();
  Set<Stmt> essentialStmts=new HashSet<Stmt>();
  LinkedList<Stmt> toVisit=new LinkedList<Stmt>();
  Chain units=b.getUnits();
{
    Iterator stmtIt=units.iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      boolean isEssential=true;
      if (s instanceof NopStmt)       isEssential=false;
      if (s instanceof AssignStmt) {
        AssignStmt as=(AssignStmt)s;
        if (as.getLeftOp() instanceof Local && (!eliminateOnlyStackLocals || ((Local)as.getLeftOp()).getName().startsWith("$"))) {
          Value rhs=as.getRightOp();
          isEssential=false;
          if (rhs instanceof InvokeExpr || rhs instanceof ArrayRef) {
            isEssential=true;
          }
          if (rhs instanceof InstanceFieldRef && !(!b.getMethod().isStatic() && ((InstanceFieldRef)rhs).getBase() == b.getThisLocal())) {
            isEssential=true;
          }
 else           if (rhs instanceof DivExpr || rhs instanceof RemExpr) {
            BinopExpr expr=(BinopExpr)rhs;
            if (expr.getOp1().getType().equals(IntType.v()) || expr.getOp2().getType().equals(IntType.v()) || expr.getOp1().getType().equals(LongType.v())|| expr.getOp2().getType().equals(LongType.v())) {
              isEssential=true;
            }
          }
 else           if (rhs instanceof CastExpr) {
            isEssential=true;
          }
 else           if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
            isEssential=true;
          }
 else           if (rhs instanceof NewExpr || (rhs instanceof FieldRef && !(rhs instanceof InstanceFieldRef))) {
            isEssential=true;
          }
        }
      }
      if (isEssential) {
        essentialStmts.add(s);
        toVisit.addLast(s);
      }
    }
  }
  ExceptionalUnitGraph graph=new ExceptionalUnitGraph(b);
  LocalDefs defs=new SmartLocalDefs(graph,new SimpleLiveLocals(graph));
  LocalUses uses=new SimpleLocalUses(graph,defs);
{
    while (!toVisit.isEmpty()) {
      Stmt s=toVisit.removeFirst();
      Iterator boxIt=s.getUseBoxes().iterator();
      while (boxIt.hasNext()) {
        ValueBox box=(ValueBox)boxIt.next();
        if (box.getValue() instanceof Local) {
          Iterator<Unit> defIt=defs.getDefsOfAt((Local)box.getValue(),s).iterator();
          while (defIt.hasNext()) {
            Stmt def=(Stmt)defIt.next();
            if (!essentialStmts.contains(def)) {
              essentialStmts.add(def);
              toVisit.addLast(def);
            }
          }
        }
      }
    }
  }
{
    Iterator stmtIt=units.iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      if (!essentialStmts.contains(s)) {
        stmtIt.remove();
        s.clearUnitBoxes();
      }
 else       if (s instanceof AssignStmt && ((AssignStmt)s).getLeftOp() == ((AssignStmt)s).getRightOp() && ((AssignStmt)s).getLeftOp() instanceof Local) {
        stmtIt.remove();
        s.clearUnitBoxes();
      }
    }
  }
{
    Iterator stmtIt=units.snapshotIterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      if (s instanceof AssignStmt && s.containsInvokeExpr()) {
        Local l=(Local)((AssignStmt)s).getLeftOp();
        InvokeExpr e=s.getInvokeExpr();
{
          Iterator useIt=uses.getUsesOf(s).iterator();
          boolean isEssential=false;
          while (useIt.hasNext()) {
            UnitValueBoxPair pair=(UnitValueBoxPair)useIt.next();
            if (essentialStmts.contains(pair.unit)) {
              isEssential=true;
              break;
            }
          }
          if (!isEssential) {
            Stmt newInvoke=Jimple.v().newInvokeStmt(e);
            newInvoke.addAllTagsOf(s);
            units.swapWith(s,newInvoke);
          }
        }
      }
    }
  }
  if (Options.v().time())   Timers.v().deadCodeTimer.end();
}
