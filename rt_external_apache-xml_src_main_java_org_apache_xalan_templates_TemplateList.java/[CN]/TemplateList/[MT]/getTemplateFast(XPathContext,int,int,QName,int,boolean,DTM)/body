{
  TemplateSubPatternAssociation head;
switch (dtm.getNodeType(targetNode)) {
case DTM.ELEMENT_NODE:
case DTM.ATTRIBUTE_NODE:
    head=(TemplateSubPatternAssociation)m_patternTable.get(dtm.getLocalNameFromExpandedNameID(expTypeID));
  break;
case DTM.TEXT_NODE:
case DTM.CDATA_SECTION_NODE:
head=m_textPatterns;
break;
case DTM.ENTITY_REFERENCE_NODE:
case DTM.ENTITY_NODE:
head=(TemplateSubPatternAssociation)m_patternTable.get(dtm.getNodeName(targetNode));
break;
case DTM.PROCESSING_INSTRUCTION_NODE:
head=(TemplateSubPatternAssociation)m_patternTable.get(dtm.getLocalName(targetNode));
break;
case DTM.COMMENT_NODE:
head=m_commentPatterns;
break;
case DTM.DOCUMENT_NODE:
case DTM.DOCUMENT_FRAGMENT_NODE:
head=m_docPatterns;
break;
case DTM.NOTATION_NODE:
default :
head=(TemplateSubPatternAssociation)m_patternTable.get(dtm.getNodeName(targetNode));
}
if (null == head) {
head=m_wildCardPatterns;
if (null == head) return null;
}
xctxt.pushNamespaceContextNull();
try {
do {
if ((maxImportLevel > -1) && (head.getImportLevel() > maxImportLevel)) {
continue;
}
ElemTemplate template=head.getTemplate();
xctxt.setNamespaceContext(template);
if ((head.m_stepPattern.execute(xctxt,targetNode,dtm,expTypeID) != NodeTest.SCORE_NONE) && head.matchMode(mode)) {
if (quietConflictWarnings) checkConflicts(head,xctxt,targetNode,mode);
return template;
}
}
 while (null != (head=head.getNext()));
}
  finally {
xctxt.popNamespaceContext();
}
return null;
}
