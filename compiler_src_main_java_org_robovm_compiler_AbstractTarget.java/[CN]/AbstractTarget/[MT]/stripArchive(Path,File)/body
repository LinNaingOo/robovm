{
  if (!config.isClean() && output.exists() && !path.hasChangedSince(output.lastModified())) {
    config.getLogger().debug("Not creating stripped archive file %s for unchanged path %s",output,path.getFile());
    return;
  }
  config.getLogger().debug("Creating stripped archive file %s",output);
  ZipOutputStream out=null;
  try {
    out=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(output)));
    if (path.getFile().isFile()) {
      ZipFile archive=null;
      try {
        archive=new ZipFile(path.getFile());
        Enumeration<? extends ZipEntry> entries=archive.entries();
        while (entries.hasMoreElements()) {
          ZipEntry entry=entries.nextElement();
          if (entry.getName().toLowerCase().endsWith(".class")) {
            continue;
          }
          ZipEntry newEntry=new ZipEntry(entry.getName());
          newEntry.setTime(entry.getTime());
          out.putNextEntry(newEntry);
          InputStream in=null;
          try {
            in=archive.getInputStream(entry);
            IOUtils.copy(in,out);
            out.closeEntry();
          }
  finally {
            IOUtils.closeQuietly(in);
          }
        }
      }
  finally {
        try {
          archive.close();
        }
 catch (        Throwable t) {
        }
      }
    }
 else {
      String basePath=path.getFile().getAbsolutePath();
      @SuppressWarnings("unchecked") Collection<File> files=FileUtils.listFiles(path.getFile(),null,true);
      for (      File f : files) {
        if (f.getName().toLowerCase().endsWith(".class")) {
          continue;
        }
        ZipEntry newEntry=new ZipEntry(f.getAbsolutePath().substring(basePath.length() + 1));
        newEntry.setTime(f.lastModified());
        out.putNextEntry(newEntry);
        InputStream in=null;
        try {
          in=new FileInputStream(f);
          IOUtils.copy(in,out);
          out.closeEntry();
        }
  finally {
          IOUtils.closeQuietly(in);
        }
      }
    }
  }
 catch (  IOException e) {
    IOUtils.closeQuietly(out);
    output.delete();
  }
 finally {
    IOUtils.closeQuietly(out);
  }
}
