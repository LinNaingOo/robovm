{
  this.mb=mb;
  this.dependencies=new HashSet<String>();
  Function f=new FunctionBuilder(t).linkage(external).build();
  if (!checkClassExists(f,t) || !checkClassAccessible(f,t)) {
    mb.addFunction(f);
    return;
  }
  if (t instanceof New) {
    SootClass target=config.getClazzes().load(t.getTarget()).getSootClass();
    if (target.isAbstract() || target.isInterface()) {
      call(f,BC_THROW_INSTANTIATION_ERROR,f.getParameterRef(0),mb.getString(t.getTarget().replace('/','.')));
      f.add(new Unreachable());
      mb.addFunction(f);
      return;
    }
    String fnName=Symbols.clinitWrapperSymbol(Symbols.allocatorSymbol(t.getTarget()));
    alias(t,fnName);
  }
 else   if (t instanceof Instanceof) {
    if (isArray(t.getTarget())) {
      String fnName=Symbols.arrayinstanceofSymbol(t.getTarget());
      if (!mb.hasSymbol(fnName)) {
        Function fn=new FunctionBuilder(t).name(fnName).linkage(weak).build();
        Value arrayClass=callLdcArray(fn,t.getTarget());
        Value result=call(fn,BC_INSTANCEOF_ARRAY,fn.getParameterRef(0),arrayClass,fn.getParameterRef(1));
        fn.add(new Ret(result));
        mb.addFunction(fn);
      }
      alias(t,fnName);
    }
 else {
      String fnName=Symbols.instanceofSymbol(t.getTarget());
      alias(t,fnName);
    }
  }
 else   if (t instanceof Checkcast) {
    if (isArray(t.getTarget())) {
      String fnName=Symbols.arraycheckcastSymbol(t.getTarget());
      if (!mb.hasSymbol(fnName)) {
        Function fn=new FunctionBuilder(t).name(fnName).linkage(weak).build();
        Value arrayClass=callLdcArray(fn,t.getTarget());
        Value result=call(fn,BC_CHECKCAST_ARRAY,fn.getParameterRef(0),arrayClass,fn.getParameterRef(1));
        fn.add(new Ret(result));
        mb.addFunction(fn);
      }
      alias(t,fnName);
    }
 else {
      String fnName=Symbols.checkcastSymbol(t.getTarget());
      alias(t,fnName);
    }
  }
 else   if (t instanceof LdcClass) {
    if (isArray(t.getTarget())) {
      FunctionRef fn=createLdcArray(t.getTarget());
      alias(t,fn.getName());
    }
 else {
      String fnName=Symbols.ldcExternalSymbol(t.getTarget());
      alias(t,fnName);
    }
  }
 else   if (t instanceof Anewarray) {
    String fnName=Symbols.anewarraySymbol(t.getTarget());
    if (!mb.hasSymbol(fnName)) {
      Function fn=new FunctionBuilder(t).name(fnName).linkage(weak).build();
      Value arrayClass=callLdcArray(fn,t.getTarget());
      Value result=call(fn,BC_NEW_OBJECT_ARRAY,fn.getParameterRef(0),fn.getParameterRef(1),arrayClass);
      fn.add(new Ret(result));
      mb.addFunction(fn);
    }
    alias(t,fnName);
  }
 else   if (t instanceof Multianewarray) {
    String fnName=Symbols.multianewarraySymbol(t.getTarget());
    if (!mb.hasSymbol(fnName)) {
      Function fn=new FunctionBuilder(t).name(fnName).linkage(weak).build();
      Value arrayClass=callLdcArray(fn,t.getTarget());
      Value result=call(fn,BC_NEW_MULTI_ARRAY,fn.getParameterRef(0),fn.getParameterRef(1),fn.getParameterRef(2),arrayClass);
      fn.add(new Ret(result));
      mb.addFunction(fn);
    }
    alias(t,fnName);
  }
 else   if (t instanceof NativeCall) {
    Clazz target=config.getClazzes().load(t.getTarget());
    NativeCall nc=(NativeCall)t;
    String shortName=mangleNativeMethod(target.getInternalName(),nc.getMethodName());
    String longName=mangleNativeMethod(target.getInternalName(),nc.getMethodName(),nc.getMethodDesc());
    if (target.isInBootClasspath() || !config.isUseDynamicJni() || config.getOs() == OS.ios) {
      Function fnLong=new FunctionBuilder(longName,nc.getFunctionType()).linkage(weak).build();
      popNativeFrame(fnLong);
      call(fnLong,BC_THROW_UNSATISIFED_LINK_ERROR,fnLong.getParameterRef(0),mb.getString(String.format(UNSATISFIED_LINK_ERROR,target.getClassName(),nc.getMethodName(),nc.getMethodDesc())));
      fnLong.add(new Unreachable());
      mb.addFunction(fnLong);
      FunctionRef targetFn=fnLong.ref();
      if (!isLongNativeFunctionNameRequired(nc)) {
        Function fnShort=new FunctionBuilder(shortName,nc.getFunctionType()).linkage(weak).build();
        Value resultInner=call(fnShort,fnLong.ref(),fnShort.getParameterRefs());
        fnShort.add(new Ret(resultInner));
        mb.addFunction(fnShort);
        targetFn=fnShort.ref();
      }
      Function fn=new FunctionBuilder(nc).linkage(_private).attribs(alwaysinline,optsize).build();
      Value result=call(fn,targetFn,fn.getParameterRefs());
      fn.add(new Ret(result));
      mb.addFunction(fn);
    }
 else {
      Global g=new Global(Symbols.nativeMethodPtrSymbol(nc),new NullConstant(I8_PTR));
      mb.addGlobal(g);
      Function fn=new FunctionBuilder(nc).linkage(_private).attribs(alwaysinline,optsize).build();
      FunctionRef ldcFn=FunctionBuilder.ldcInternal(nc.getTarget()).ref();
      Value theClass=call(fn,ldcFn,fn.getParameterRef(0));
      Value implI8Ptr=call(fn,BC_RESOLVE_NATIVE,fn.getParameterRef(0),theClass,mb.getString(nc.getMethodName()),mb.getString(nc.getMethodDesc()),mb.getString(mangleNativeMethod(nc.getTarget(),nc.getMethodName())),mb.getString(mangleNativeMethod(nc.getTarget(),nc.getMethodName(),nc.getMethodDesc())),g.ref());
      Variable nullTest=fn.newVariable(I1);
      fn.add(new Icmp(nullTest,Condition.ne,implI8Ptr,new NullConstant(I8_PTR)));
      Label trueLabel=new Label();
      Label falseLabel=new Label();
      fn.add(new Br(nullTest.ref(),fn.newBasicBlockRef(trueLabel),fn.newBasicBlockRef(falseLabel)));
      fn.newBasicBlock(falseLabel);
      if (fn.getType().getReturnType() instanceof IntegerType) {
        fn.add(new Ret(new IntegerConstant(0,(IntegerType)fn.getType().getReturnType())));
      }
 else       if (fn.getType().getReturnType() instanceof FloatingPointType) {
        fn.add(new Ret(new FloatingPointConstant(0.0,(FloatingPointType)fn.getType().getReturnType())));
      }
 else       if (fn.getType().getReturnType() instanceof PointerType) {
        fn.add(new Ret(new NullConstant((PointerType)fn.getType().getReturnType())));
      }
 else {
        fn.add(new Ret());
      }
      fn.newBasicBlock(trueLabel);
      Variable impl=fn.newVariable(nc.getFunctionType());
      fn.add(new Bitcast(impl,implI8Ptr,impl.getType()));
      Value result=call(fn,impl.ref(),fn.getParameterRefs());
      fn.add(new Ret(result));
      mb.addFunction(fn);
    }
  }
 else   if (t instanceof FieldAccessor) {
    SootField field=resolveField(f,(FieldAccessor)t);
    if (field != null) {
      dependencies.add(getInternalName(field.getDeclaringClass()));
    }
    if (field == null || !checkMemberAccessible(f,t,field)) {
      mb.addFunction(f);
      return;
    }
    Clazz caller=config.getClazzes().load(t.getCallingClass());
    Clazz target=config.getClazzes().load(t.getTarget());
    if (!((FieldAccessor)t).isGetter() && field.isFinal() && caller != target) {
      throwIllegalAccessError(f,ATTEMPT_TO_WRITE_TO_FINAL_FIELD,target,field.getName(),caller);
      mb.addFunction(f);
      return;
    }
    if (!field.isStatic()) {
      createInlinedAccessorForInstanceField((FieldAccessor)t,field);
    }
 else {
      createTrampolineAliasForField((FieldAccessor)t,field);
    }
  }
 else   if (t instanceof Invokeinterface) {
    SootMethod rm=resolveInterfaceMethod(f,(Invokeinterface)t);
    if (rm != null) {
      dependencies.add(getInternalName(rm.getDeclaringClass()));
    }
    if (rm == null || !checkMemberAccessible(f,t,rm)) {
      mb.addFunction(f);
      return;
    }
    createTrampolineAliasForMethod((Invoke)t,rm);
  }
 else   if (t instanceof Invoke) {
    SootMethod method=resolveMethod(f,(Invoke)t);
    if (method != null) {
      dependencies.add(getInternalName(method.getDeclaringClass()));
    }
    if (method == null || !checkMemberAccessible(f,t,method)) {
      mb.addFunction(f);
      return;
    }
    if (t instanceof Invokespecial && method.isAbstract()) {
      call(f,BC_THROW_ABSTRACT_METHOD_ERROR,f.getParameterRef(0),mb.getString(String.format(NO_SUCH_METHOD_ERROR,method.getDeclaringClass(),method.getName(),getDescriptor(method))));
      f.add(new Unreachable());
      mb.addFunction(f);
      return;
    }
    createTrampolineAliasForMethod((Invoke)t,method);
  }
}
