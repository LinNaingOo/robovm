{
  Type[] ret=cache.get(descriptor);
  if (ret != null)   return ret;
  char[] d=descriptor.toCharArray();
  int p=0;
  conversionTypes.clear();
  outer:   while (p < d.length) {
    boolean isArray=false;
    int numDimensions=0;
    Type baseType=null;
    swtch:     while (p < d.length) {
switch (d[p]) {
case '(':
case ')':
        p++;
      continue outer;
case '[':
    isArray=true;
  numDimensions++;
p++;
continue swtch;
case 'B':
baseType=ByteType.v();
p++;
break swtch;
case 'C':
baseType=CharType.v();
p++;
break swtch;
case 'D':
baseType=DoubleType.v();
p++;
break swtch;
case 'F':
baseType=FloatType.v();
p++;
break swtch;
case 'I':
baseType=IntType.v();
p++;
break swtch;
case 'J':
baseType=LongType.v();
p++;
break swtch;
case 'L':
int index=p + 1;
while (index < d.length && d[index] != ';') {
if (d[index] == '/') d[index]='.';
index++;
}
if (index >= d.length) throw new RuntimeException("Class reference has no ending ;");
String className=new String(d,p + 1,index - p - 1);
baseType=RefType.v(className);
p=index + 1;
break swtch;
case 'S':
baseType=ShortType.v();
p++;
break swtch;
case 'Z':
baseType=BooleanType.v();
p++;
break swtch;
case 'V':
baseType=VoidType.v();
p++;
break swtch;
default :
throw new RuntimeException("Unknown field type!");
}
}
if (baseType == null) continue;
Type t;
if (isArray) t=ArrayType.v(baseType,numDimensions);
 else t=baseType;
conversionTypes.add(t);
}
ret=conversionTypes.toArray(new Type[0]);
cache.put(descriptor,ret);
return ret;
}
