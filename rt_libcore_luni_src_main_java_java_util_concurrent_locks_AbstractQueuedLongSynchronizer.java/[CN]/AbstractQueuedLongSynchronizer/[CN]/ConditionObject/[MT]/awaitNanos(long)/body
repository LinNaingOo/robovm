{
  if (Thread.interrupted())   throw new InterruptedException();
  Node node=addConditionWaiter();
  long savedState=fullyRelease(node);
  final long deadline=System.nanoTime() + nanosTimeout;
  int interruptMode=0;
  while (!isOnSyncQueue(node)) {
    if (nanosTimeout <= 0L) {
      transferAfterCancelledWait(node);
      break;
    }
    if (nanosTimeout >= spinForTimeoutThreshold)     LockSupport.parkNanos(this,nanosTimeout);
    if ((interruptMode=checkInterruptWhileWaiting(node)) != 0)     break;
    nanosTimeout=deadline - System.nanoTime();
  }
  if (acquireQueued(node,savedState) && interruptMode != THROW_IE)   interruptMode=REINTERRUPT;
  if (node.nextWaiter != null)   unlinkCancelledWaiters();
  if (interruptMode != 0)   reportInterruptAfterWait(interruptMode);
  return deadline - System.nanoTime();
}
