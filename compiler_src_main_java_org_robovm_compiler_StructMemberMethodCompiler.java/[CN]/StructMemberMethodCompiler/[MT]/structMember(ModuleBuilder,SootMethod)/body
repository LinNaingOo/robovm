{
  SootClass sootClass=method.getDeclaringClass();
  StructureType structType=getStructType(sootClass);
  if (structType == null) {
    throw new IllegalArgumentException("Struct class " + sootClass + " has no @StructMember annotated methods");
  }
  Function function=FunctionBuilder.structMember(method);
  moduleBuilder.addFunction(function);
  Variable handleI64=function.newVariable(I64);
  function.add(new Load(handleI64,getFieldPtr(function,function.getParameterRef(1),offsetof(new StructureType(OBJECT,new StructureType(I64)),1,0),I64)));
  Variable handlePtr=function.newVariable(new PointerType(structType));
  function.add(new Inttoptr(handlePtr,handleI64.ref(),handlePtr.getType()));
  int offset=getStructMemberOffset(method);
  Type memberType=structType.getTypeAt(offset);
  Variable memberPtr=function.newVariable(new PointerType(memberType));
  function.add(new Getelementptr(memberPtr,handlePtr.ref(),0,offset));
  StructMemberPair pair=getStructMemberPair(sootClass,offset);
  VariableRef env=function.getParameterRef(0);
  if (method == pair.getGetter()) {
    if (needsMarshaler(method.getReturnType())) {
      Value result=null;
      if (isPassByValue(method)) {
        result=memberPtr.ref();
      }
 else {
        Variable tmp=function.newVariable(memberType);
        function.add(new Load(tmp,memberPtr.ref()));
        result=tmp.ref();
      }
      Variable handle=function.newVariable(I64);
      function.add(new Ptrtoint(handle,result,I64));
      String marshalerClassName=getMarshalerClassName(method,true);
      if (isPtr(method.getReturnType())) {
        SootClass sootPtrTargetClass=getPtrTargetClass(method);
        Value ptrTargetClass=ldcClass(function,getInternalName(sootPtrTargetClass),env);
        int ptrWrapCount=getPtrWrapCount(method);
        Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),marshalerClassName,"toPtr","(Ljava/lang/Class;JI)Lorg/robovm/rt/bro/ptr/Ptr;");
        trampolines.add(invokestatic);
        result=call(function,invokestatic.getFunctionRef(),env,ptrTargetClass,handle.ref(),new IntegerConstant(ptrWrapCount));
      }
 else {
        String targetClassName=getInternalName(method.getReturnType());
        Value returnClass=ldcClass(function,targetClassName,env);
        Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),marshalerClassName,"toObject","(Ljava/lang/Class;JZ)Ljava/lang/Object;");
        trampolines.add(invokestatic);
        result=call(function,invokestatic.getFunctionRef(),env,returnClass,handle.ref(),new IntegerConstant((byte)0));
      }
      function.add(new Ret(result));
    }
 else     if (hasPointerAnnotation(method)) {
      Variable tmp=function.newVariable(I8_PTR);
      function.add(new Load(tmp,memberPtr.ref()));
      Variable result=function.newVariable(I64);
      function.add(new Ptrtoint(result,tmp.ref(),I64));
      function.add(new Ret(result.ref()));
    }
 else {
      Variable result=function.newVariable(memberType);
      function.add(new Load(result,memberPtr.ref()));
      function.add(new Ret(result.ref()));
    }
  }
 else {
    Value p=function.getParameterRef(2);
    if (needsMarshaler(method.getParameterType(0))) {
      boolean copy=!isPtr(method.getReturnType()) && isPassByValue(method,0);
      if (copy) {
        call(function,CHECK_NULL,env,p);
      }
      String marshalerClassName=getMarshalerClassName(method,0,false);
      Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),marshalerClassName,"toNative","(Ljava/lang/Object;)J");
      trampolines.add(invokestatic);
      Value ptrI64=call(function,invokestatic.getFunctionRef(),env,p);
      Variable ptr=function.newVariable(I8_PTR);
      function.add(new Inttoptr(ptr,ptrI64,I8_PTR));
      if (copy) {
        Variable memberI8Ptr=function.newVariable(I8_PTR);
        function.add(new Bitcast(memberI8Ptr,memberPtr.ref(),I8_PTR));
        call(function,LLVM_MEMCPY,memberI8Ptr.ref(),ptr.ref(),sizeof((StructureType)memberType),new IntegerConstant(1),BooleanConstant.FALSE);
      }
 else {
        function.add(new Store(ptr.ref(),memberPtr.ref()));
      }
    }
 else     if (hasPointerAnnotation(method,0)) {
      Variable ptr=function.newVariable(I8_PTR);
      function.add(new Inttoptr(ptr,p,I8_PTR));
      function.add(new Store(ptr.ref(),memberPtr.ref()));
    }
 else {
      function.add(new Store(p,memberPtr.ref()));
    }
    if (method.getReturnType().equals(VoidType.v())) {
      function.add(new Ret());
    }
 else {
      function.add(new Ret(function.getParameterRef(1)));
    }
  }
}
