{
  closeEntry();
  if (entriesEnd) {
    return null;
  }
  Streams.readFully(in,hdrBuf,0,4);
  int hdr=Memory.peekInt(hdrBuf,0,ByteOrder.LITTLE_ENDIAN);
  if (hdr == CENSIG) {
    entriesEnd=true;
    return null;
  }
  if (hdr != LOCSIG) {
    return null;
  }
  Streams.readFully(in,hdrBuf,0,(LOCHDR - LOCVER));
  int version=peekShort(0) & 0xff;
  if (version > ZIPLocalHeaderVersionNeeded) {
    throw new ZipException("Cannot read local header version " + version);
  }
  int flags=peekShort(LOCFLG - LOCVER);
  hasDD=((flags & ZipFile.GPBF_DATA_DESCRIPTOR_FLAG) != 0);
  int ceLastModifiedTime=peekShort(LOCTIM - LOCVER);
  int ceLastModifiedDate=peekShort(LOCTIM - LOCVER + 2);
  int ceCompressionMethod=peekShort(LOCHOW - LOCVER);
  long ceCrc=0, ceCompressedSize=0, ceSize=-1;
  if (!hasDD) {
    ceCrc=((long)Memory.peekInt(hdrBuf,LOCCRC - LOCVER,ByteOrder.LITTLE_ENDIAN)) & 0xffffffffL;
    ceCompressedSize=((long)Memory.peekInt(hdrBuf,LOCSIZ - LOCVER,ByteOrder.LITTLE_ENDIAN)) & 0xffffffffL;
    ceSize=((long)Memory.peekInt(hdrBuf,LOCLEN - LOCVER,ByteOrder.LITTLE_ENDIAN)) & 0xffffffffL;
  }
  int nameLength=peekShort(LOCNAM - LOCVER);
  if (nameLength == 0) {
    throw new ZipException("Entry is not named");
  }
  int extraLength=peekShort(LOCEXT - LOCVER);
  if (nameLength > nameBuf.length) {
    nameBuf=new byte[nameLength];
    charBuf=new char[nameLength];
  }
  Streams.readFully(in,nameBuf,0,nameLength);
  currentEntry=createZipEntry(ModifiedUtf8.decode(nameBuf,charBuf,0,nameLength));
  currentEntry.time=ceLastModifiedTime;
  currentEntry.modDate=ceLastModifiedDate;
  currentEntry.setMethod(ceCompressionMethod);
  if (ceSize != -1) {
    currentEntry.setCrc(ceCrc);
    currentEntry.setSize(ceSize);
    currentEntry.setCompressedSize(ceCompressedSize);
  }
  if (extraLength > 0) {
    byte[] extraData=new byte[extraLength];
    Streams.readFully(in,extraData,0,extraLength);
    currentEntry.setExtra(extraData);
  }
  return currentEntry;
}
