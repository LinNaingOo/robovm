{
  int rightBound=matchResult.getRightBound();
  int SyllIndex=0;
  int[] decompSyllable=new int[Lexer.MAX_HANGUL_DECOMPOSITION_LENGTH];
  int[] decompCurSymb;
  char curSymb;
  int LIndex=-1;
  int VIndex=-1;
  int TIndex=-1;
  if (strIndex >= rightBound) {
    return -1;
  }
  curSymb=testString.charAt(strIndex++);
  decompCurSymb=Lexer.getHangulDecomposition(curSymb);
  if (decompCurSymb == null) {
    decompSyllable[SyllIndex++]=curSymb;
    LIndex=curSymb - Lexer.LBase;
    if ((LIndex < 0) || (LIndex >= Lexer.LCount)) {
      return -1;
    }
    if (strIndex < rightBound) {
      curSymb=testString.charAt(strIndex);
      VIndex=curSymb - Lexer.VBase;
    }
    if ((VIndex < 0) || (VIndex >= Lexer.VCount)) {
      return -1;
    }
    strIndex++;
    decompSyllable[SyllIndex++]=curSymb;
    if (strIndex < rightBound) {
      curSymb=testString.charAt(strIndex);
      TIndex=curSymb - Lexer.TBase;
    }
    if ((TIndex < 0) || (TIndex >= Lexer.TCount)) {
      return ((decomposedCharLength == 2) && (decompSyllable[0] == decomposedChar[0]) && (decompSyllable[1] == decomposedChar[1])) ? next.matches(strIndex,testString,matchResult) : -1;
    }
    strIndex++;
    decompSyllable[SyllIndex++]=curSymb;
    return ((decomposedCharLength == 3) && (decompSyllable[0] == decomposedChar[0]) && (decompSyllable[1] == decomposedChar[1])&& (decompSyllable[2] == decomposedChar[2])) ? next.matches(strIndex,testString,matchResult) : -1;
  }
 else {
    int i=0;
    if (decompCurSymb.length != decomposedCharLength) {
      return -1;
    }
    for (; i < decomposedCharLength; i++) {
      if (decompCurSymb[i] != decomposedChar[i]) {
        return -1;
      }
    }
    return next.matches(strIndex,testString,matchResult);
  }
}
