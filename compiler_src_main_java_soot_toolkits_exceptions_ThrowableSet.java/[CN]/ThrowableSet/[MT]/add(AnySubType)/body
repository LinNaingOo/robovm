{
  if (INSTRUMENTING) {
    Manager.v().addsOfAnySubType++;
  }
  ThrowableSet result=getMemoizedAdds(e);
  if (result != null) {
    if (INSTRUMENTING) {
      Manager.v().addsInclusionFromMemo++;
      Manager.v().addsExclusionWithoutSearch++;
    }
    return result;
  }
 else {
    FastHierarchy hierarchy=Scene.v().getOrMakeFastHierarchy();
    RefType newBase=e.getBase();
    if (INSTRUMENTING) {
      if (exceptionsExcluded.size() != 0) {
        Manager.v().addsExclusionWithSearch++;
      }
 else {
        Manager.v().addsExclusionWithoutSearch++;
      }
    }
    for (Iterator i=exceptionsExcluded.iterator(); i.hasNext(); ) {
      RefType exclusionBase=((AnySubType)i.next()).getBase();
      if (hierarchy.canStoreType(newBase,exclusionBase) || hierarchy.canStoreType(exclusionBase,newBase)) {
        if (INSTRUMENTING) {
          Manager.v().addsInclusionInterrupted++;
        }
        throw new AlreadyHasExclusionsException("ThrowableSet.add(" + e.toString() + ") to the set [ "+ this.toString()+ "] where "+ exclusionBase.toString()+ " is excluded.");
      }
    }
    if (this.exceptionsIncluded.contains(e)) {
      if (INSTRUMENTING) {
        Manager.v().addsInclusionFromMap++;
      }
      return this;
    }
 else {
      if (INSTRUMENTING) {
        Manager.v().addsInclusionFromSearch++;
      }
      int changes=0;
      boolean addNewException=true;
      Set resultSet=new HashSet();
      for (Iterator i=this.exceptionsIncluded.iterator(); i.hasNext(); ) {
        RefLikeType incumbent=(RefLikeType)i.next();
        if (incumbent instanceof RefType) {
          if (hierarchy.canStoreType(incumbent,newBase)) {
            changes++;
          }
 else {
            resultSet.add(incumbent);
          }
        }
 else         if (incumbent instanceof AnySubType) {
          RefType incumbentBase=((AnySubType)incumbent).getBase();
          if (hierarchy.canStoreType(newBase,incumbentBase)) {
            addNewException=false;
            resultSet.add(incumbent);
          }
 else           if (hierarchy.canStoreType(incumbentBase,newBase)) {
            changes++;
          }
 else {
            resultSet.add(incumbent);
          }
        }
 else {
          throw new IllegalStateException("ThrowableSet.add(AnySubType): Set element " + incumbent.toString() + " is neither a RefType nor an AnySubType.");
        }
      }
      if (addNewException) {
        resultSet.add(e);
        changes++;
      }
      if (changes > 0) {
        result=Manager.v().registerSetIfNew(resultSet,this.exceptionsExcluded);
      }
 else {
        result=this;
      }
      memoizedAdds.put(e,result);
      return result;
    }
  }
}
