{
  this.graph=g;
  if (Options.v().time())   Timers.v().defsTimer.start();
  if (Options.v().verbose())   G.v().out.println("[" + g.getBody().getMethod().getName() + "]     Constructing SmartLocalDefs...");
  localToDefs=new HashMap<Local,HashSet<Unit>>();
  unitToMask=new HashMap<Unit,HashSet>();
  for (Iterator uIt=g.iterator(); uIt.hasNext(); ) {
    final Unit u=(Unit)uIt.next();
    Local l=localDef(u);
    if (l == null)     continue;
    HashSet<Unit> s=defsOf(l);
    s.add(u);
  }
  if (Options.v().verbose())   G.v().out.println("[" + g.getBody().getMethod().getName() + "]        done localToDefs map...");
  for (Iterator uIt=g.iterator(); uIt.hasNext(); ) {
    final Unit u=(Unit)uIt.next();
    unitToMask.put(u,new HashSet(live.getLiveLocalsAfter(u)));
  }
  if (Options.v().verbose())   G.v().out.println("[" + g.getBody().getMethod().getName() + "]        done unitToMask map...");
  analysis=new LocalDefsAnalysis(graph);
  answer=new HashMap<Cons,ArrayList<Unit>>();
  for (Iterator uIt=graph.iterator(); uIt.hasNext(); ) {
    final Unit u=(Unit)uIt.next();
    for (Iterator vbIt=u.getUseBoxes().iterator(); vbIt.hasNext(); ) {
      final ValueBox vb=(ValueBox)vbIt.next();
      Value v=vb.getValue();
      if (!(v instanceof Local))       continue;
      HashSet analysisResult=(HashSet)analysis.getFlowBefore(u);
      ArrayList<Unit> al=new ArrayList<Unit>();
      for (      Unit unit : defsOf((Local)v)) {
        if (analysisResult.contains(unit))         al.add(unit);
      }
      answer.put(new Cons(u,v),al);
    }
  }
  if (Options.v().time())   Timers.v().defsTimer.end();
  if (Options.v().verbose())   G.v().out.println("[" + g.getBody().getMethod().getName() + "]     SmartLocalDefs finished.");
}
