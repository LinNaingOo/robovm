{
  if (!isIndexValid(sources,offset,length)) {
    throw new IndexOutOfBoundsException();
  }
  checkOpenConnected();
  if (calculateTotalRemaining(sources,offset,length) == 0) {
    return 0;
  }
  Object[] src=new Object[length];
  int[] offsets=new int[length];
  int[] lengths=new int[length];
  for (int i=0; i < length; i++) {
    ByteBuffer buffer=sources[i + offset];
    if (!buffer.isDirect()) {
      if (buffer.hasArray()) {
        src[i]=buffer.array();
        offsets[i]=buffer.position();
      }
 else {
        ByteBuffer directBuffer=ByteBuffer.allocateDirect(buffer.remaining());
        int oldPosition=buffer.position();
        directBuffer.put(buffer);
        buffer.position(oldPosition);
        directBuffer.flip();
        src[i]=directBuffer;
        offsets[i]=0;
      }
    }
 else {
      src[i]=buffer;
      offsets[i]=buffer.position();
    }
    lengths[i]=buffer.remaining();
  }
  long bytesWritten=writevImpl(src,offsets,lengths);
  long bytesRemaining=bytesWritten;
  for (int i=offset; i < length + offset; i++) {
    if (bytesRemaining > sources[i].remaining()) {
      int pos=sources[i].limit();
      bytesRemaining-=sources[i].remaining();
      sources[i].position(pos);
    }
 else {
      int pos=sources[i].position() + (int)bytesRemaining;
      sources[i].position(pos);
      break;
    }
  }
  return bytesWritten;
}
