{
  if (offset < 0 || length < 0 || (offset + length) > sources.length) {
    throw new IndexOutOfBoundsException();
  }
  openCheck();
  if (calculateTotalRemaining(sources,offset,length) == 0) {
    return 0;
  }
  Object[] src=new Object[length];
  int[] offsets=new int[length];
  int[] lengths=new int[length];
  for (int i=0; i < length; i++) {
    ByteBuffer buffer=sources[i + offset];
    if (!buffer.isDirect()) {
      if (buffer.hasArray()) {
        src[i]=buffer.array();
        offsets[i]=buffer.position();
      }
 else {
        ByteBuffer directBuffer=ByteBuffer.allocateDirect(buffer.remaining());
        int oldPosition=buffer.position();
        directBuffer.put(buffer);
        buffer.position(oldPosition);
        directBuffer.flip();
        src[i]=directBuffer;
        offsets[i]=0;
      }
    }
 else {
      src[i]=buffer;
      offsets[i]=buffer.position();
    }
    lengths[i]=buffer.remaining();
  }
  long bytesWritten=0;
  boolean completed=false;
synchronized (repositioningLock) {
    try {
      begin();
      bytesWritten=fileSystem.writev(handle,src,offsets,lengths,length);
      completed=true;
    }
  finally {
      end(completed);
    }
  }
  long bytesRemaining=bytesWritten;
  for (int i=offset; i < length + offset; i++) {
    if (bytesRemaining > sources[i].remaining()) {
      int pos=sources[i].limit();
      bytesRemaining-=sources[i].remaining();
      sources[i].position(pos);
    }
 else {
      int pos=sources[i].position() + (int)bytesRemaining;
      sources[i].position(pos);
      break;
    }
  }
  return bytesWritten;
}
