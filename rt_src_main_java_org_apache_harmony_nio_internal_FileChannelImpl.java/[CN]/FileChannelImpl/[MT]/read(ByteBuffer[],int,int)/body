{
  int count=0;
  if (offset < 0 || length < 0 || offset + length > buffers.length) {
    throw new IndexOutOfBoundsException();
  }
  openCheck();
  if (calculateTotalRemaining(buffers,offset,length) == 0) {
    return 0;
  }
  ByteBuffer[] directBuffers=new ByteBuffer[length];
  long[] handles=new long[length];
  int[] offsets=new int[length];
  int[] lengths=new int[length];
  for (int i=0; i < length; i++) {
    ByteBuffer buffer=buffers[i + offset];
    if (!buffer.isDirect()) {
      buffer=ByteBuffer.allocateDirect(buffer.remaining());
      directBuffers[i]=buffer;
      offsets[i]=0;
    }
 else {
      offsets[i]=buffer.position();
    }
    handles[i]=((DirectBuffer)buffer).getEffectiveAddress().toLong();
    lengths[i]=buffer.remaining();
  }
  long bytesRead=0;
{
    boolean completed=false;
    try {
      begin();
synchronized (repositioningLock) {
        bytesRead=fileSystem.readv(handle,handles,offsets,lengths,length);
      }
      completed=true;
    }
  finally {
      end(completed);
    }
  }
  int end=offset + length;
  long bytesRemaining=bytesRead;
  for (int i=offset; i < end && bytesRemaining > 0; i++) {
    if (buffers[i].isDirect()) {
      if (lengths[i] < bytesRemaining) {
        int pos=buffers[i].limit();
        buffers[i].position(pos);
        bytesRemaining-=lengths[i];
      }
 else {
        int pos=(int)bytesRemaining;
        buffers[i].position(pos);
        break;
      }
    }
 else {
      ByteBuffer buf=directBuffers[i - offset];
      if (bytesRemaining < buf.remaining()) {
        int pos=buf.position();
        buffers[i].put(buf);
        buffers[i].position(pos + (int)bytesRemaining);
        bytesRemaining=0;
      }
 else {
        bytesRemaining-=buf.remaining();
        buffers[i].put(buf);
      }
    }
  }
  return bytesRead;
}
