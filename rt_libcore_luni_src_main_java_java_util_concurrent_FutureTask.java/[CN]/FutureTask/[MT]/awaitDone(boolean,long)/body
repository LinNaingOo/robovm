{
  final long deadline=timed ? System.nanoTime() + nanos : 0L;
  WaitNode q=null;
  boolean queued=false;
  for (; ; ) {
    if (Thread.interrupted()) {
      removeWaiter(q);
      throw new InterruptedException();
    }
    int s=state;
    if (s > COMPLETING) {
      if (q != null)       q.thread=null;
      return s;
    }
 else     if (s == COMPLETING)     Thread.yield();
 else     if (q == null)     q=new WaitNode();
 else     if (!queued)     queued=UNSAFE.compareAndSwapObject(this,waitersOffset,q.next=waiters,q);
 else     if (timed) {
      nanos=deadline - System.nanoTime();
      if (nanos <= 0L) {
        removeWaiter(q);
        return state;
      }
      LockSupport.parkNanos(this,nanos);
    }
 else     LockSupport.park(this);
  }
}
