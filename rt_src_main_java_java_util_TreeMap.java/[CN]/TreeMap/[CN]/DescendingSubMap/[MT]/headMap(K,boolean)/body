{
  this.keyCompare(end,end);
  K inclusiveEnd=end;
  boolean isInRange=true;
  if (null != inclusiveEnd) {
    int result;
    if (toEnd) {
      result=(null != comparator()) ? comparator().compare(inclusiveEnd,hi) : toComparable(inclusiveEnd).compareTo(hi);
      isInRange=(hiInclusive || !inclusive) ? result <= 0 : result < 0;
    }
    if (fromStart) {
      result=(null != comparator()) ? comparator().compare(inclusiveEnd,lo) : toComparable(inclusiveEnd).compareTo(lo);
      isInRange=isInRange && ((loInclusive || !inclusive) ? result >= 0 : result > 0);
    }
  }
  if (isInRange) {
    if (this.fromStart) {
      return new DescendingSubMap<K,V>(this.lo,this.loInclusive,m,end,inclusive);
    }
    return new DescendingSubMap<K,V>(m,end,inclusive);
  }
  throw new IllegalArgumentException();
}
