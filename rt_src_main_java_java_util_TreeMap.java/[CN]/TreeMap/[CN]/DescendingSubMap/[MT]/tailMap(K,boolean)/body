{
  this.keyCompare(start,start);
  K inclusiveStart=start;
  boolean isInRange=true;
  int result;
  if (null != inclusiveStart) {
    if (toEnd) {
      result=(null != comparator()) ? comparator().compare(inclusiveStart,hi) : toComparable(inclusiveStart).compareTo(hi);
      isInRange=(hiInclusive || !inclusive) ? result <= 0 : result < 0;
    }
    if (fromStart) {
      result=(null != comparator()) ? comparator().compare(inclusiveStart,lo) : toComparable(inclusiveStart).compareTo(lo);
      isInRange=isInRange && ((loInclusive || !inclusive) ? result >= 0 : result > 0);
    }
  }
  if (isInRange) {
    if (this.toEnd) {
      return new DescendingSubMap<K,V>(start,inclusive,m,this.hi,this.hiInclusive);
    }
    return new DescendingSubMap<K,V>(start,inclusive,m);
  }
  throw new IllegalArgumentException();
}
