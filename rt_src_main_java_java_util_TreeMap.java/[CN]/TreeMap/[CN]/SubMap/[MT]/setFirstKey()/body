{
  if (firstKeyModCount == backingMap.modCount) {
    return;
  }
  Comparable<K> object=backingMap.comparator == null ? toComparable((K)startKey) : null;
  K key=(K)startKey;
  Node<K,V> node=backingMap.root;
  Node<K,V> foundNode=null;
  int foundIndex=-1;
  TOP_LOOP:   while (node != null) {
    K[] keys=node.keys;
    int left_idx=node.left_idx;
    int result=backingMap.cmp(object,key,keys[left_idx]);
    if (result < 0) {
      foundNode=node;
      foundIndex=node.left_idx;
      node=node.left;
    }
 else     if (result == 0) {
      foundNode=node;
      foundIndex=node.left_idx;
      break;
    }
 else {
      int right_idx=node.right_idx;
      if (left_idx != right_idx) {
        result=backingMap.cmp(object,key,keys[right_idx]);
      }
      if (result > 0) {
        node=node.right;
      }
 else       if (result == 0) {
        foundNode=node;
        foundIndex=node.right_idx;
        break;
      }
 else {
        foundNode=node;
        foundIndex=node.right_idx;
        int low=left_idx + 1, mid=0, high=right_idx - 1;
        while (low <= high) {
          mid=(low + high) >>> 1;
          result=backingMap.cmp(object,key,keys[mid]);
          if (result > 0) {
            low=mid + 1;
          }
 else           if (result == 0) {
            foundNode=node;
            foundIndex=mid;
            break TOP_LOOP;
          }
 else {
            foundNode=node;
            foundIndex=mid;
            high=mid - 1;
          }
        }
        break TOP_LOOP;
      }
    }
  }
  boolean isBounded=true;
  if (hasEnd && foundNode != null) {
    Comparator<? super K> cmp=backingMap.comparator;
    if (cmp == null) {
      isBounded=(toComparable(foundNode.keys[foundIndex]).compareTo(endKey) <= 0);
    }
 else {
      isBounded=(cmp.compare(foundNode.keys[foundIndex],endKey) <= 0);
    }
  }
  if (foundNode != null && !isBounded) {
    foundNode=null;
  }
  firstKeyNode=foundNode;
  firstKeyIndex=foundIndex;
  firstKeyModCount=backingMap.modCount;
}
