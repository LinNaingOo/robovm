{
  if (fromStart && ((!loInclusive && inclusive) ? m.keyCompare(end,lo) <= 0 : m.keyCompare(end,lo) < 0)) {
    throw new IllegalArgumentException();
  }
  if (toEnd && ((!hiInclusive && inclusive) ? m.keyCompare(end,hi) >= 0 : m.keyCompare(end,hi) > 0)) {
    throw new IllegalArgumentException();
  }
  if (checkUpperBound(end)) {
    if (this.fromStart) {
      return new AscendingSubMap<K,V>(this.lo,this.loInclusive,m,end,inclusive);
    }
    return new AscendingSubMap<K,V>(m,end,inclusive);
  }
 else {
    return this;
  }
}
