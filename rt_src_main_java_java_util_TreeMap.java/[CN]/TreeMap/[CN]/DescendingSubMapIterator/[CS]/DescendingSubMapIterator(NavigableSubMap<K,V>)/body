{
  super(map);
  TreeMap.Entry<K,V> entry;
  if (map.fromStart) {
    entry=map.loInclusive ? map.m.findFloorEntry(map.lo) : map.m.findLowerEntry(map.lo);
  }
 else {
    entry=map.m.findBiggestEntry();
  }
  if (entry != null) {
    if (!map.isInRange(entry.key)) {
      node=null;
      return;
    }
    node=entry.node;
    offset=entry.index;
  }
 else {
    node=null;
    return;
  }
  boundaryPair=getBoundaryNode();
  if (boundaryPair != null) {
    if (map.m.keyCompare(boundaryPair.key,entry.key) > 0) {
      node=null;
    }
  }
  if (map.toEnd && !map.hiInclusive) {
    if (map.m.keyCompare(map.hi,entry.key) == 0) {
      node=null;
    }
  }
}
