{
  super(g);
  Object[] defs;
  FlowUniverse defUniverse;
  if (Options.v().time())   Timers.v().defsSetupTimer.start();
{
    Map<Local,ArrayList> localToDefList=new HashMap<Local,ArrayList>(g.getBody().getLocalCount() * 2 + 1,0.7f);
{
      Iterator localIt=g.getBody().getLocals().iterator();
      while (localIt.hasNext()) {
        Local l=(Local)localIt.next();
        localToDefList.put(l,new ArrayList());
      }
    }
{
      Iterator it=g.iterator();
      while (it.hasNext()) {
        Unit s=(Unit)it.next();
        List defBoxes=s.getDefBoxes();
        if (!defBoxes.isEmpty()) {
          if (!(defBoxes.size() == 1))           throw new RuntimeException("invalid number of def boxes");
          if (((ValueBox)defBoxes.get(0)).getValue() instanceof Local) {
            Local defLocal=(Local)((ValueBox)defBoxes.get(0)).getValue();
            List<Unit> l=localToDefList.get(defLocal);
            if (l == null)             throw new RuntimeException("local " + defLocal + " is used but not declared!");
 else             l.add(s);
          }
        }
      }
    }
{
      Iterator it=g.getBody().getLocals().iterator();
      List defList=new LinkedList();
      int startPos=0;
      localToIntPair=new HashMap<Local,IntPair>(g.getBody().getLocalCount() * 2 + 1,0.7f);
{
        while (it.hasNext()) {
          Local l=(Local)it.next();
          Iterator jt=localToDefList.get(l).iterator();
          int endPos=startPos - 1;
          while (jt.hasNext()) {
            defList.add(jt.next());
            endPos++;
          }
          localToIntPair.put(l,new IntPair(startPos,endPos));
          startPos=endPos + 1;
        }
      }
      defs=defList.toArray();
      defUniverse=new ArrayFlowUniverse(defs);
    }
  }
  emptySet=new ArrayPackedSet(defUniverse);
{
    Map<Local,FlowSet> localToKillSet=new HashMap<Local,FlowSet>(g.getBody().getLocalCount() * 2 + 1,0.7f);
    localToPreserveSet=new HashMap<Local,BoundedFlowSet>(g.getBody().getLocalCount() * 2 + 1,0.7f);
    Chain locals=g.getBody().getLocals();
{
      Iterator localIt=locals.iterator();
      while (localIt.hasNext()) {
        Local l=(Local)localIt.next();
        localToKillSet.put(l,emptySet.clone());
      }
    }
    for (    Object element : defs) {
      Unit s=(Unit)element;
      List defBoxes=s.getDefBoxes();
      if (!(defBoxes.size() == 1))       throw new RuntimeException("SimpleLocalDefs: invalid number of def boxes");
      if (((ValueBox)defBoxes.get(0)).getValue() instanceof Local) {
        Local defLocal=(Local)((ValueBox)defBoxes.get(0)).getValue();
        BoundedFlowSet killSet=(BoundedFlowSet)localToKillSet.get(defLocal);
        killSet.add(s,killSet);
      }
    }
{
      Iterator localIt=locals.iterator();
      while (localIt.hasNext()) {
        Local l=(Local)localIt.next();
        BoundedFlowSet killSet=(BoundedFlowSet)localToKillSet.get(l);
        killSet.complement(killSet);
        localToPreserveSet.put(l,killSet);
      }
    }
  }
  if (Options.v().time())   Timers.v().defsSetupTimer.end();
  if (Options.v().time())   Timers.v().defsAnalysisTimer.start();
  doAnalysis();
  if (Options.v().time())   Timers.v().defsAnalysisTimer.end();
}
