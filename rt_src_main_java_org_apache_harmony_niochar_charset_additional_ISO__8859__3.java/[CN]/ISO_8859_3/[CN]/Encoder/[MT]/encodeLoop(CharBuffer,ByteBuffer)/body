{
  int bbRemaining=bb.remaining();
  if (CharsetProviderImpl.hasLoadedNatives() && bb.isDirect() && cb.hasRemaining()&& cb.hasArray()) {
    int toProceed=cb.remaining();
    int cbPos=cb.position();
    int bbPos=bb.position();
    boolean throwOverflow=false;
    if (bbRemaining < toProceed) {
      toProceed=bbRemaining;
      throwOverflow=true;
    }
    int[] res={toProceed,0};
    nEncode(AddressUtil.getDirectBufferAddress(bb),bbPos,cb.array(),cb.arrayOffset() + cbPos,res);
    if (res[0] <= 0) {
      bb.position(bbPos - res[0]);
      cb.position(cbPos - res[0]);
      if (res[1] != 0) {
        if (res[1] < 0)         return CoderResult.malformedForLength(-res[1]);
 else         return CoderResult.unmappableForLength(res[1]);
      }
    }
 else {
      bb.position(bbPos + res[0]);
      cb.position(cbPos + res[0]);
      if (throwOverflow)       return CoderResult.OVERFLOW;
    }
  }
 else {
    if (bb.hasArray() && cb.hasArray()) {
      byte[] byteArr=bb.array();
      char[] charArr=cb.array();
      int rem=cb.remaining();
      int byteArrStart=bb.position();
      rem=bbRemaining <= rem ? bbRemaining : rem;
      int x;
      for (x=cb.position(); x < cb.position() + rem; x++) {
        char c=charArr[x];
        if (c > (char)0x02D9) {
          if (c >= 0xD800 && c <= 0xDFFF) {
            if (x + 1 < cb.limit()) {
              char c1=charArr[x + 1];
              if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                cb.position(x);
                bb.position(byteArrStart);
                return CoderResult.unmappableForLength(2);
              }
            }
 else {
              cb.position(x);
              bb.position(byteArrStart);
              return CoderResult.UNDERFLOW;
            }
            cb.position(x);
            bb.position(byteArrStart);
            return CoderResult.malformedForLength(1);
          }
          cb.position(x);
          bb.position(byteArrStart);
          return CoderResult.unmappableForLength(1);
        }
 else {
          if (c < 0xA1) {
            byteArr[byteArrStart++]=(byte)c;
          }
 else {
            int index=(int)c >> 8;
            index=encodeIndex[index];
            if (index < 0) {
              cb.position(x);
              bb.position(byteArrStart);
              return CoderResult.unmappableForLength(1);
            }
            index<<=8;
            index+=(int)c & 0xFF;
            if ((byte)arr[index] != 0) {
              byteArr[byteArrStart++]=(byte)arr[index];
            }
 else {
              cb.position(x);
              bb.position(byteArrStart);
              return CoderResult.unmappableForLength(1);
            }
          }
        }
      }
      cb.position(x);
      bb.position(byteArrStart);
      if (rem == bbRemaining && cb.hasRemaining()) {
        return CoderResult.OVERFLOW;
      }
    }
 else {
      while (cb.hasRemaining()) {
        if (bbRemaining == 0)         return CoderResult.OVERFLOW;
        char c=cb.get();
        if (c > (char)0x02D9) {
          if (c >= 0xD800 && c <= 0xDFFF) {
            if (cb.hasRemaining()) {
              char c1=cb.get();
              if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                cb.position(cb.position() - 2);
                return CoderResult.unmappableForLength(2);
              }
 else {
                cb.position(cb.position() - 1);
              }
            }
 else {
              cb.position(cb.position() - 1);
              return CoderResult.UNDERFLOW;
            }
            cb.position(cb.position() - 1);
            return CoderResult.malformedForLength(1);
          }
          cb.position(cb.position() - 1);
          return CoderResult.unmappableForLength(1);
        }
 else {
          if (c < 0xA1) {
            bb.put((byte)c);
          }
 else {
            int index=(int)c >> 8;
            index=encodeIndex[index];
            if (index < 0) {
              cb.position(cb.position() - 1);
              return CoderResult.unmappableForLength(1);
            }
            index<<=8;
            index+=(int)c & 0xFF;
            if ((byte)arr[index] != 0) {
              bb.put((byte)arr[index]);
            }
 else {
              cb.position(cb.position() - 1);
              return CoderResult.unmappableForLength(1);
            }
          }
          bbRemaining--;
        }
      }
    }
  }
  return CoderResult.UNDERFLOW;
}
