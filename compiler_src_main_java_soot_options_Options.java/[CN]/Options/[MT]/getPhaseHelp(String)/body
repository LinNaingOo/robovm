{
  if (phaseName.equals("jb"))   return "Phase " + phaseName + ":\n"+ "\nJimple Body Creation creates a JimpleBody for each input \nmethod, using either coffi, to read .class files, or the jimple \nparser, to read .jimple files. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("use-original-names (false)","")+ padOpt("preserve-source-annotations (false)","");
  if (phaseName.equals("jb.ls"))   return "Phase " + phaseName + ":\n"+ "\nThe Local Splitter identifies DU-UD webs for local variables \nand introduces new variables so that each disjoint web is \nassociated with a single local. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jb.a"))   return "Phase " + phaseName + ":\n"+ "\nThe Jimple Local Aggregator removes some unnecessary copies by \ncombining local variables. Essentially, it finds definitions \nwhich have only a single use and, if it is safe to do so, \nremoves the original definition after replacing the use with the \ndefinition's right-hand side. At this stage in JimpleBody \nconstruction, local aggregation serves largely to remove the \ncopies to and from stack variables which simulate load and store \ninstructions in the original bytecode."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("jb.ule"))   return "Phase " + phaseName + ":\n"+ "\nThe Unused Local Eliminator removes any unused locals from the \nmethod. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jb.tr"))   return "Phase " + phaseName + ":\n"+ "\nThe Type Assigner gives local variables types which will \naccommodate the values stored in them over the course of the \nmethod. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("ignore-wrong-staticness (false)","Ignores errors due to wrong staticness")+ padOpt("use-older-type-assigner (false)","Enables the older type assigner")+ padOpt("compare-type-assigners (false)","Compares Ben Bellamy's and the older type assigner");
  if (phaseName.equals("jb.ulp"))   return "Phase " + phaseName + ":\n"+ "\nThe Unsplit-originals Local Packer executes only when the \n`use-original-names' option is chosen for the `jb' phase. The \nLocal Packer attempts to minimize the number of local variables \nrequired in a method by reusing the same variable for disjoint \nDU-UD webs. Conceptually, it is the inverse of the Local \nSplitter. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("unsplit-original-locals (true)","");
  if (phaseName.equals("jb.lns"))   return "Phase " + phaseName + ":\n"+ "\nThe Local Name Standardizer assigns generic names to local \nvariables. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (false)","");
  if (phaseName.equals("jb.cp"))   return "Phase " + phaseName + ":\n"+ "\nThis phase performs cascaded copy propagation. If the \npropagator encounters situations of the form: A: a = ...; \n... B: x = a; ... C: ... = ... x; where a and x are \neach defined only once (at A and B, respectively), then it can \npropagate immediately without checking between B and C for \nredefinitions of a. In this case the propagator is global. \nOtherwise, if a has multiple definitions then the propagator \nchecks for redefinitions and propagates copies only within \nextended basic blocks. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-regular-locals (false)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("jb.dae"))   return "Phase " + phaseName + ":\n"+ "\nThe Dead Assignment Eliminator eliminates assignment statements \nto locals whose values are not subsequently used, unless \nevaluating the right-hand side of the assignment may cause \nside-effects. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("jb.cp-ule"))   return "Phase " + phaseName + ":\n"+ "\nThis phase removes any locals that are unused after copy \npropagation. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jb.lp"))   return "Phase " + phaseName + ":\n"+ "\nThe Local Packer attempts to minimize the number of local \nvariables required in a method by reusing the same variable for \ndisjoint DU-UD webs. Conceptually, it is the inverse of the \nLocal Splitter. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("unsplit-original-locals (false)","");
  if (phaseName.equals("jb.ne"))   return "Phase " + phaseName + ":\n"+ "\nThe Nop Eliminator removes nop statements from the method. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jb.uce"))   return "Phase " + phaseName + ":\n"+ "\nThe Unreachable Code Eliminator removes unreachable code and \ntraps whose catch blocks are empty. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("remove-unreachable-traps (false)","");
  if (phaseName.equals("jb.tt"))   return "Phase " + phaseName + ":\n"+ "\nThe Trap Tightener changes the area protected by each exception \nhandler, so that it begins with the first instruction in the old \nprotected area which is actually capable of throwing an \nexception caught by the handler, and ends just after the last \ninstruction in the old protected area which can throw an \nexception caught by the handler. This reduces the chance of \nproducing unverifiable code as a byproduct of pruning \nexceptional control flow within CFGs. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jj"))   return "Phase " + phaseName + ":\n"+ "\nJimple Body Creation creates a JimpleBody for each input \nmethod, using polyglot, to read .java files. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("use-original-names (true)","");
  if (phaseName.equals("jj.ls"))   return "Phase " + phaseName + ":\n"+ "\nThe Local Splitter identifies DU-UD webs for local variables \nand introduces new variables so that each disjoint web is \nassociated with a single local. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jj.a"))   return "Phase " + phaseName + ":\n"+ "\nThe Jimple Local Aggregator removes some unnecessary copies by \ncombining local variables. Essentially, it finds definitions \nwhich have only a single use and, if it is safe to do so, \nremoves the original definition after replacing the use with the \ndefinition's right-hand side. At this stage in JimpleBody \nconstruction, local aggregation serves largely to remove the \ncopies to and from stack variables which simulate load and store \ninstructions in the original bytecode."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("jj.ule"))   return "Phase " + phaseName + ":\n"+ "\nThe Unused Local Eliminator removes any unused locals from the \nmethod. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jj.tr"))   return "Phase " + phaseName + ":\n"+ "\nThe Type Assigner gives local variables types which will \naccommodate the values stored in them over the course of the \nmethod. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jj.ulp"))   return "Phase " + phaseName + ":\n"+ "\nThe Unsplit-originals Local Packer executes only when the \n`use-original-names' option is chosen for the `jb' phase. The \nLocal Packer attempts to minimize the number of local variables \nrequired in a method by reusing the same variable for disjoint \nDU-UD webs. Conceptually, it is the inverse of the Local \nSplitter. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("unsplit-original-locals (false)","");
  if (phaseName.equals("jj.lns"))   return "Phase " + phaseName + ":\n"+ "\nThe Local Name Standardizer assigns generic names to local \nvariables. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (false)","");
  if (phaseName.equals("jj.cp"))   return "Phase " + phaseName + ":\n"+ "\nThis phase performs cascaded copy propagation. If the \npropagator encounters situations of the form: A: a = ...; \n... B: x = a; ... C: ... = ... x; where a and x are \neach defined only once (at A and B, respectively), then it can \npropagate immediately without checking between B and C for \nredefinitions of a. In this case the propagator is global. \nOtherwise, if a has multiple definitions then the propagator \nchecks for redefinitions and propagates copies only within \nextended basic blocks. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-regular-locals (false)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("jj.dae"))   return "Phase " + phaseName + ":\n"+ "\nThe Dead Assignment Eliminator eliminates assignment statements \nto locals whose values are not subsequently used, unless \nevaluating the right-hand side of the assignment may cause \nside-effects. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("jj.cp-ule"))   return "Phase " + phaseName + ":\n"+ "\nThis phase removes any locals that are unused after copy \npropagation. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jj.lp"))   return "Phase " + phaseName + ":\n"+ "\nThe Local Packer attempts to minimize the number of local \nvariables required in a method by reusing the same variable for \ndisjoint DU-UD webs. Conceptually, it is the inverse of the \nLocal Splitter. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("unsplit-original-locals (false)","");
  if (phaseName.equals("jj.ne"))   return "Phase " + phaseName + ":\n"+ "\nThe Nop Eliminator removes nop statements from the method. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jj.uce"))   return "Phase " + phaseName + ":\n"+ "\nThe Unreachable Code Eliminator removes unreachable code and \ntraps whose catch blocks are empty. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("cg"))   return "Phase " + phaseName + ":\n"+ "\nThe Call Graph Constructor computes a call graph for whole \nprogram analysis. When this pack finishes, a call graph is \navailable in the Scene. The different phases in this pack are \ndifferent ways to construct the call graph. Exactly one phase in \nthis pack must be enabled; Soot will raise an error otherwise. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("safe-forname (false)","Handle Class.forName() calls conservatively")+ padOpt("safe-newinstance (false)","Handle Class.newInstance() calls conservatively")+ padOpt("verbose (false)","Print warnings about where the call graph may be incomplete")+ padOpt("jdkver (3)","JDK version for native methods")+ padOpt("all-reachable (false)","Assume all methods of application classes are reachable.")+ padOpt("implicit-entry (true)","Include methods called implicitly by the VM as entry points")+ padOpt("trim-clinit (true)","Removes redundant static initializer calls")+ padOpt("reflection-log","Uses a reflection log to resolve reflective calls.")+ padOpt("guards (ignore)","Describes how to guard the program from unsound assumptions.");
  if (phaseName.equals("cg.cha"))   return "Phase " + phaseName + ":\n"+ "\nThis phase uses Class Hierarchy Analysis to generate a call \ngraph."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("verbose (false)","Print statistics about the resulting call graph");
  if (phaseName.equals("cg.spark"))   return "Phase " + phaseName + ":\n"+ "\nSpark is a flexible points-to analysis framework. Aside from \nbuilding a call graph, it also generates information about the \ntargets of pointers. For details about Spark, please see Ondrej \nLhotak's M.Sc. thesis."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("verbose (false)","Print detailed information about the execution of Spark")+ padOpt("ignore-types (false)","Make Spark completely ignore declared types of variables")+ padOpt("force-gc (false)","Force garbage collection for measuring memory usage")+ padOpt("pre-jimplify (false)","Jimplify all methods before starting Spark")+ padOpt("vta (false)","Emulate Variable Type Analysis")+ padOpt("rta (false)","Emulate Rapid Type Analysis")+ padOpt("field-based (false)","Use a field-based rather than field-sensitive representation")+ padOpt("types-for-sites (false)","Represent objects by their actual type rather than allocation site")+ padOpt("merge-stringbuffer (true)","Represent all StringBuffers as one object")+ padOpt("string-constants (false)","Propagate all string constants, not just class names")+ padOpt("simulate-natives (true)","Simulate effects of native methods in standard class library")+ padOpt("empties-as-allocs (false)","Treat singletons for empty sets etc. as allocation sites")+ padOpt("simple-edges-bidirectional (false)","Equality-based analysis between variable nodes")+ padOpt("on-fly-cg (true)","Build call graph as receiver types become known")+ padOpt("simplify-offline (false)","Collapse single-entry subgraphs of the PAG")+ padOpt("simplify-sccs (false)","Collapse strongly-connected components of the PAG")+ padOpt("ignore-types-for-sccs (false)","Ignore declared types when determining node equivalence for SCCs")+ padOpt("propagator","Select propagation algorithm")+ padVal("iter","Simple iterative algorithm")+ padVal("worklist (default)","Fast, worklist-based algorithm")+ padVal("cycle","Unfinished on-the-fly cycle detection algorithm")+ padVal("merge","Unfinished field reference merging algorithms")+ padVal("alias","Alias-edge based algorithm")+ padVal("none","Disable propagation")+ padOpt("set-impl","Select points-to set implementation")+ padVal("hash","Use Java HashSet")+ padVal("bit","Bit vector")+ padVal("hybrid","Hybrid representation using bit vector for large sets")+ padVal("array","Sorted array representation")+ padVal("heintze","Heintze's shared bit-vector and overflow list representation")+ padVal("sharedlist","Shared list representation")+ padVal("double (default)","Double set representation for incremental propagation")+ padOpt("double-set-old","Select implementation of points-to set for old part of double set")+ padVal("hash","Use Java HashSet")+ padVal("bit","Bit vector")+ padVal("hybrid (default)","Hybrid representation using bit vector for large sets")+ padVal("array","Sorted array representation")+ padVal("heintze","Heintze's shared bit-vector and overflow list representation")+ padVal("sharedlist","Shared list representation")+ padOpt("double-set-new","Select implementation of points-to set for new part of double set")+ padVal("hash","Use Java HashSet")+ padVal("bit","Bit vector")+ padVal("hybrid (default)","Hybrid representation using bit vector for large sets")+ padVal("array","Sorted array representation")+ padVal("heintze","Heintze's shared bit-vector and overflow list representation")+ padVal("sharedlist","Shared list representation")+ padOpt("dump-html (false)","Dump pointer assignment graph to HTML for debugging")+ padOpt("dump-pag (false)","Dump pointer assignment graph for other solvers")+ padOpt("dump-solution (false)","Dump final solution for comparison with other solvers")+ padOpt("topo-sort (false)","Sort variable nodes in dump")+ padOpt("dump-types (true)","Include declared types in dump")+ padOpt("class-method-var (true)","In dump, label variables by class and method")+ padOpt("dump-answer (false)","Dump computed reaching types for comparison with other solvers")+ padOpt("add-tags (false)","Output points-to results in tags for viewing with the Jimple")+ padOpt("set-mass (false)","Calculate statistics about points-to set sizes")+ padOpt("cs-demand (false)","After running Spark, refine points-to sets on demand with context information")+ padOpt("lazy-pts (true)","Create lazy points-to sets that create context information only when needed.")+ padOpt("traversal (75000)","Make the analysis traverse at most this number of nodes per query.")+ padOpt("passes (10)","Perform at most this number of refinement iterations.");
  if (phaseName.equals("cg.paddle"))   return "Phase " + phaseName + ":\n"+ "\nPaddle is a BDD-based interprocedural analysis framework. It \nincludes points-to analysis, call graph construction, and \nvarious client analyses."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("verbose (false)","Print detailed information about the execution of Paddle")+ padOpt("conf","Select Paddle configuration")+ padVal("ofcg (default)","On-the fly call graph")+ padVal("cha","CHA only")+ padVal("cha-aot","CHA ahead-of-time callgraph")+ padVal("ofcg-aot","OFCG-AOT callgraph")+ padVal("cha-context-aot","CHA-Context-AOT callgraph")+ padVal("ofcg-context-aot","OFCG-Context-AOT callgraph")+ padVal("cha-context","CHA-Context callgraph")+ padVal("ofcg-context","OFCG-Context callgraph")+ padOpt("bdd (false)","Use BDD version of Paddle")+ padOpt("order (32)","")+ padOpt("dynamic-order","")+ padOpt("profile (false)","Profile BDDs using JeddProfiler")+ padOpt("verbosegc (false)","Print memory usage at each BDD garbage collection.")+ padOpt("q","Select queue implementation")+ padVal("auto (default)","Select queue implementation based on bdd option")+ padVal("trad","Normal worklist queue implementation")+ padVal("bdd","BDD-based queue implementation")+ padVal("debug","Debugging queue implementation")+ padVal("trace","Tracing queue implementation")+ padVal("numtrace","Number-tracing queue implementation")+ padOpt("backend","Select BDD backend")+ padVal("auto (default)","Select backend based on bdd option")+ padVal("buddy","BuDDy backend")+ padVal("cudd","CUDD backend")+ padVal("sable","SableJBDD backend")+ padVal("javabdd","JavaBDD backend")+ padVal("none","No BDDs")+ padOpt("bdd-nodes (0)","Number of BDD nodes to allocate (0=unlimited)")+ padOpt("ignore-types (false)","Make Paddle completely ignore declared types of variables")+ padOpt("pre-jimplify (false)","Jimplify all methods before starting Paddle")+ padOpt("context","Select context-sensitivity level")+ padVal("insens (default)","Builds a context-insensitive call graph")+ padVal("1cfa","Builds a 1-CFA call graph")+ padVal("kcfa","Builds a k-CFA call graph")+ padVal("objsens","Builds an object-sensitive call graph")+ padVal("kobjsens","Builds a k-object-sensitive call graph")+ padVal("uniqkobjsens","Builds a unique-k-object-sensitive call graph")+ padVal("threadkobjsens","Experimental option for thread-entry-point sensitivity")+ padOpt("k (2)","")+ padOpt("context-heap (false)","Treat allocation sites context-sensitively")+ padOpt("rta (false)","Emulate Rapid Type Analysis")+ padOpt("field-based (false)","Use a field-based rather than field-sensitive representation")+ padOpt("types-for-sites (false)","Represent objects by their actual type rather than allocation site")+ padOpt("merge-stringbuffer (true)","Represent all StringBuffers as one object")+ padOpt("string-constants (false)","Propagate all string constants, not just class names")+ padOpt("simulate-natives (true)","Simulate effects of native methods in standard class library")+ padOpt("global-nodes-in-natives (false)","Use global node to model variables in simulations of native methods")+ padOpt("simple-edges-bidirectional (false)","Equality-based analysis between variable nodes")+ padOpt("this-edges (false)","Use pointer assignment edges to model this parameters")+ padOpt("precise-newinstance (true)","Make newInstance only allocate objects of dynamic classes")+ padOpt("propagator","Select propagation algorithm")+ padVal("auto (default)","Select propagation algorithm based on bdd option")+ padVal("iter","Simple iterative algorithm")+ padVal("worklist","Fast, worklist-based algorithm")+ padVal("alias","Alias-edge based algorithm")+ padVal("bdd","BDD-based propagator")+ padVal("incbdd","Incrementalized BDD-based propagator")+ padOpt("set-impl","Select points-to set implementation")+ padVal("hash","Use Java HashSet")+ padVal("bit","Bit vector")+ padVal("hybrid","Hybrid representation using bit vector for large sets")+ padVal("array","Sorted array representation")+ padVal("heintze","Heintze's shared bit-vector and overflow list representation")+ padVal("double (default)","Double set representation for incremental propagation")+ padOpt("double-set-old","Select implementation of points-to set for old part of double set")+ padVal("hash","Use Java HashSet")+ padVal("bit","Bit vector")+ padVal("hybrid (default)","Hybrid representation using bit vector for large sets")+ padVal("array","Sorted array representation")+ padVal("heintze","Heintze's shared bit-vector and overflow list representation")+ padOpt("double-set-new","Select implementation of points-to set for new part of double set")+ padVal("hash","Use Java HashSet")+ padVal("bit","Bit vector")+ padVal("hybrid (default)","Hybrid representation using bit vector for large sets")+ padVal("array","Sorted array representation")+ padVal("heintze","Heintze's shared bit-vector and overflow list representation")+ padOpt("context-counts (false)","Print number of contexts for each method")+ padOpt("total-context-counts (false)","Print total number of contexts")+ padOpt("method-context-counts (false)","Print number of contexts for each method")+ padOpt("set-mass (false)","Calculate statistics about points-to set sizes")+ padOpt("number-nodes (true)","Print node numbers in dumps");
  if (phaseName.equals("wstp"))   return "Phase " + phaseName + ":\n"+ "\nSoot can perform whole-program analyses. In whole-shimple \nmode, Soot applies the contents of the Whole-Shimple \nTransformation Pack to the scene as a whole after constructing a \ncall graph for the program. In an unmodified copy of Soot the \nWhole-Shimple Transformation Pack is empty."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("wsop"))   return "Phase " + phaseName + ":\n"+ "\nIf Soot is running in whole shimple mode and the Whole-Shimple \nOptimization Pack is enabled, the pack's transformations are \napplied to the scene as a whole after construction of the call \ngraph and application of any enabled Whole-Shimple \nTransformations. In an unmodified copy of Soot the Whole-Shimple \nOptimization Pack is empty."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("wjtp"))   return "Phase " + phaseName + ":\n"+ "\nSoot can perform whole-program analyses. In whole-program \nmode, Soot applies the contents of the Whole-Jimple \nTransformation Pack to the scene as a whole after constructing a \ncall graph for the program."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("wjtp.mhp"))   return "Phase " + phaseName + ":\n"+ "\nMay Happen in Parallel (MHP) Analyses determine what program \nstatements may be run by different threads concurrently. This \nphase does not perform any transformation. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("wjtp.tn"))   return "Phase " + phaseName + ":\n"+ "\nThe Lock Allocator finds critical sections (synchronized \nregions) in Java programs and assigns locks for execution on \nboth optimistic and pessimistic JVMs. It can also be used to \nanalyze the existing locks. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("locking-scheme","Selects the granularity of the generated lock allocation")+ padVal("medium-grained (default)","Use a runtime object for synchronization where possible")+ padVal("coarse-grained","Use static objects for synchronization")+ padVal("single-static","Use just one static synchronization object for all transactional regions")+ padVal("leave-original","Analyse the existing lock structure without making changes")+ padOpt("avoid-deadlock (true)","Perform Deadlock Avoidance")+ padOpt("open-nesting (true)","Use an open nesting model")+ padOpt("do-mhp (true)","Perform a May-Happen-in-Parallel analysis")+ padOpt("do-tlo (true)","Perform a Local-Objects analysis")+ padOpt("print-graph (false)","Print topological graph of transactions")+ padOpt("print-table (false)","Print table of transactions")+ padOpt("print-debug (false)","Print debugging info");
  if (phaseName.equals("wjop"))   return "Phase " + phaseName + ":\n"+ "\nIf Soot is running in whole program mode and the Whole-Jimple \nOptimization Pack is enabled, the pack's transformations are \napplied to the scene as a whole after construction of the call \ngraph and application of any enabled Whole-Jimple \nTransformations."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("wjop.smb"))   return "Phase " + phaseName + ":\n"+ "\nThe Static Method Binder statically binds monomorphic call \nsites. That is, it searches the call graph for virtual method \ninvocations that can be determined statically to call only a \nsingle implementation of the called method. Then it replaces \nsuch virtual invocations with invocations of a static copy of \nthe single called implementation. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("insert-null-checks (true)","")+ padOpt("insert-redundant-casts (true)","")+ padOpt("allowed-modifier-changes","")+ padVal("unsafe (default)","")+ padVal("safe","")+ padVal("none","");
  if (phaseName.equals("wjop.si"))   return "Phase " + phaseName + ":\n"+ "\nThe Static Inliner visits all call sites in the call graph in a \nbottom-up fashion, replacing monomorphic calls with inlined \ncopies of the invoked methods. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("rerun-jb (true)","")+ padOpt("insert-null-checks (true)","")+ padOpt("insert-redundant-casts (true)","")+ padOpt("allowed-modifier-changes","")+ padVal("unsafe (default)","")+ padVal("safe","")+ padVal("none","")+ padOpt("expansion-factor (3)","")+ padOpt("max-container-size (5000)","")+ padOpt("max-inlinee-size (20)","");
  if (phaseName.equals("wjap"))   return "Phase " + phaseName + ":\n"+ "\nSome analyses do not transform Jimple body directly, but \nannotate statements or values with tags. Whole-Jimple annotation \npack provides a place for annotation-oriented analyses in whole \nprogram mode."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("wjap.ra"))   return "Phase " + phaseName + ":\n"+ "\nThe Rectangular Array Finder traverses Jimple statements based \non the static call graph, and finds array variables which always \nhold rectangular two-dimensional array objects. In Java, a \nmulti-dimensional array is an array of arrays, which means the \nshape of the array can be ragged. Nevertheless, many \napplications use rectangular arrays. Knowing that an array is \nrectangular can be very helpful in proving safe array bounds \nchecks. The Rectangular Array Finder does not change the program \nbeing analyzed. Its results are used by the Array Bound Checker."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("wjap.umt"))   return "Phase " + phaseName + ":\n"+ "\nUses the call graph to determine which methods are unreachable \nand adds color tags so they can be highlighted in a source \nbrowser."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("wjap.uft"))   return "Phase " + phaseName + ":\n"+ "\nUses the call graph to determine which fields are unreachable \nand adds color tags so they can be highlighted in a source \nbrowser."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("wjap.tqt"))   return "Phase " + phaseName + ":\n"+ "\nDetermines which methods and fields have qualifiers that could \nbe tightened. For example: if a field or method has the \nqualifier of public but is only used within the declaring class \nit could be private. This, this field or method is tagged with \ncolor tags so that the results can be highlighted in a source \nbrowser."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("wjap.cgg"))   return "Phase " + phaseName + ":\n"+ "\nCreates graphical call graph."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("show-lib-meths (false)","");
  if (phaseName.equals("wjap.purity"))   return "Phase " + phaseName + ":\n"+ "\nPurity anaysis implemented by Antoine Mine and based on the \npaper A Combined Pointer and Purity Analysis for Java Programs \nby Alexandru Salcianu and Martin Rinard. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("dump-summaries (true)","")+ padOpt("dump-cg (false)","")+ padOpt("dump-intra (false)","")+ padOpt("print (true)","")+ padOpt("verbose (false)","");
  if (phaseName.equals("shimple"))   return "Phase " + phaseName + ":\n"+ "\nShimple Control sets parameters which apply throughout the \ncreation and manipulation of Shimple bodies. Shimple is Soot's \nSSA representation."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("node-elim-opt (true)","Node elimination optimizations")+ padOpt("standard-local-names (false)","Uses naming scheme of the Local Name             Standardizer.")+ padOpt("extended (false)","Compute extended SSA (SSI) form.")+ padOpt("debug (false)","Enables debugging output, if any.");
  if (phaseName.equals("stp"))   return "Phase " + phaseName + ":\n"+ "\nWhen the Shimple representation is produced, Soot \napplies the contents of the Shimple Transformation \nPack to each method under analysis. This pack \ncontains no transformations in an unmodified version \nof Soot. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("sop"))   return "Phase " + phaseName + ":\n"+ "\nThe Shimple Optimization Pack contains \ntransformations that perform optimizations on \nShimple, Soot's SSA representation. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("sop.cpf"))   return "Phase " + phaseName + ":\n"+ "\nA powerful constant propagator and folder based \non an algorithm sketched by Cytron et al that \ntakes conditional control flow into account. This \noptimization demonstrates some of the benefits of \nSSA -- particularly the fact that Phi nodes \nrepresent natural merge points in the control \nflow. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("prune-cfg (true)","Take advantage of CFG optimization             opportunities.");
  if (phaseName.equals("jtp"))   return "Phase " + phaseName + ":\n"+ "\nSoot applies the contents of the Jimple Transformation Pack to \neach method under analysis. This pack contains no \ntransformations in an unmodified version of Soot. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jop"))   return "Phase " + phaseName + ":\n"+ "\nWhen Soot's Optimize option is on, Soot applies the Jimple \nOptimization Pack to every JimpleBody in application classes. \nThis section lists the default transformations in the Jimple \nOptimization Pack. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","Eliminates common subexpressions");
  if (phaseName.equals("jop.cse"))   return "Phase " + phaseName + ":\n"+ "\nThe Common Subexpression Eliminator runs an available \nexpressions analysis on the method body, then eliminates common \nsubexpressions. This implementation is especially slow, as it \nruns on individual statements rather than on basic blocks. A \nbetter implementation (which would find most common \nsubexpressions, but not all) would use basic blocks instead. \nThis implementation is also slow because the flow universe is \nexplicitly created; it need not be. A better implementation \nwould implicitly compute the kill sets at every node. Because \nof its current slowness, this transformation is not enabled by \ndefault. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("naive-side-effect (false)","Use naive side effect analysis even if interprocedural information is available");
  if (phaseName.equals("jop.bcm"))   return "Phase " + phaseName + ":\n"+ "\nBusy Code Motion is a straightforward implementation of Partial \nRedundancy Elimination. This implementation is not very \naggressive. Lazy Code Motion is an improved version which \nshould be used instead of Busy Code Motion. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("naive-side-effect (false)","Use a naive side effect analysis even if interprocedural information is available");
  if (phaseName.equals("jop.lcm"))   return "Phase " + phaseName + ":\n"+ "\nLazy Code Motion is an enhanced version of Busy Code Motion, a \nPartial Redundancy Eliminator. Before doing Partial Redundancy \nElimination, this optimization performs loop inversion (turning \nwhile loops into do while loops inside an if statement). This \nallows the Partial Redundancy Eliminator to optimize loop \ninvariants of while loops. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("safety","")+ padVal("safe (default)","")+ padVal("medium","")+ padVal("unsafe","")+ padOpt("unroll (true)","")+ padOpt("naive-side-effect (false)","Use a naive side effect analysis even if interprocedural information is available");
  if (phaseName.equals("jop.cp"))   return "Phase " + phaseName + ":\n"+ "\nThis phase performs cascaded copy propagation."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-regular-locals (false)","")+ padOpt("only-stack-locals (false)","");
  if (phaseName.equals("jop.cpf"))   return "Phase " + phaseName + ":\n"+ "\nThe Jimple Constant Propagator and Folder evaluates any \nexpressions consisting entirely of compile-time constants, for \nexample 2 * 3, and replaces the expression with the constant \nresult, in this case 6. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jop.cbf"))   return "Phase " + phaseName + ":\n"+ "\nThe Conditional Branch Folder statically evaluates the \nconditional expression of Jimple if statements. If the \ncondition is identically true or false, the Folder replaces the \nconditional branch statement with an unconditional goto \nstatement. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jop.dae"))   return "Phase " + phaseName + ":\n"+ "\nThe Dead Assignment Eliminator eliminates assignment statements \nto locals whose values are not subsequently used, unless \nevaluating the right-hand side of the assignment may cause \nside-effects. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-tag (false)","")+ padOpt("only-stack-locals (false)","");
  if (phaseName.equals("jop.nce"))   return "Phase " + phaseName + ":\n"+ "\nReplaces statements 'if(x!=null) goto y' with 'goto y' if x is \nknown to be non-null or with 'nop' if it is known to be null, \netc. Generates dead code and is hence followed by unreachable \ncode elimination. Disabled by default because it can be \nexpensive on methods with many locals. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jop.uce1"))   return "Phase " + phaseName + ":\n"+ "\nThe Unreachable Code Eliminator removes unreachable code and \ntraps whose catch blocks are empty. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("remove-unreachable-traps (false)","");
  if (phaseName.equals("jop.ubf1"))   return "Phase " + phaseName + ":\n"+ "\nThe Unconditional Branch Folder removes unnecessary `goto' \nstatements from a JimpleBody. If a goto statement's target is \nthe next instruction, then the statement is removed. If a \ngoto's target is another goto, with target y, then the first \nstatement's target is changed to y. If some if statement's \ntarget is a goto statement, then the if's target can be replaced \nwith the goto's target. (These situations can result from other \noptimizations, and branch folding may itself generate more \nunreachable code.)"+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jop.uce2"))   return "Phase " + phaseName + ":\n"+ "\nAnother iteration of the Unreachable Code Eliminator. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("remove-unreachable-traps (false)","");
  if (phaseName.equals("jop.ubf2"))   return "Phase " + phaseName + ":\n"+ "\nAnother iteration of the Unconditional Branch Folder. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jop.ule"))   return "Phase " + phaseName + ":\n"+ "\nThe Unused Local Eliminator phase removes any unused locals \nfrom the method. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jap"))   return "Phase " + phaseName + ":\n"+ "\nThe Jimple Annotation Pack contains phases which add \nannotations to Jimple bodies individually (as opposed to the \nWhole-Jimple Annotation Pack, which adds annotations based on \nthe analysis of the whole program). "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("jap.npc"))   return "Phase " + phaseName + ":\n"+ "\nThe Null Pointer Checker finds instruction which have the \npotential to throw NullPointerExceptions and adds annotations \nindicating whether or not the pointer being dereferenced can be \ndetermined statically not to be null. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("only-array-ref (false)","Annotate only array references")+ padOpt("profiling (false)","Insert instructions to count safe pointer accesses");
  if (phaseName.equals("jap.npcolorer"))   return "Phase " + phaseName + ":\n"+ "\nProduce colour tags that the Soot plug-in for Eclipse can use \nto highlight null and non-null references. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.abc"))   return "Phase " + phaseName + ":\n"+ "\nThe Array Bound Checker performs a static analysis to determine \nwhich array bounds checks may safely be eliminated and then \nannotates statements with the results of the analysis. If Soot \nis in whole-program mode, the Array Bound Checker can use the \nresults provided by the Rectangular Array Finder."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("with-all (false)","")+ padOpt("with-cse (false)","")+ padOpt("with-arrayref (false)","")+ padOpt("with-fieldref (false)","")+ padOpt("with-classfield (false)","")+ padOpt("with-rectarray (false)","")+ padOpt("profiling (false)","Profile the results of array bounds check analysis.")+ padOpt("add-color-tags (false)","Add color tags to results of array bound check analysis.");
  if (phaseName.equals("jap.profiling"))   return "Phase " + phaseName + ":\n"+ "\nThe Profiling Generator inserts the method invocations required \nto initialize and to report the results of any profiling \nperformed by the Null Pointer Checker and Array Bound Checker. \nUsers of the Profiling Generator must provide a MultiCounter \nclass implementing the methods invoked. For details, see the \nProfilingGenerator source code. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("notmainentry (false)","Instrument runBenchmark() instead of main()");
  if (phaseName.equals("jap.sea"))   return "Phase " + phaseName + ":\n"+ "\nThe Side Effect Tagger uses the active invoke graph to produce \nside-effect attributes, as described in the Spark thesis, \nchapter 6."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("naive (false)","");
  if (phaseName.equals("jap.fieldrw"))   return "Phase " + phaseName + ":\n"+ "\nThe Field Read/Write Tagger uses the active invoke graph to \nproduce tags indicating which fields may be read or written by \neach statement, including invoke statements."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("threshold (100)","");
  if (phaseName.equals("jap.cgtagger"))   return "Phase " + phaseName + ":\n"+ "\nThe Call Graph Tagger produces LinkTags based on the call \ngraph. The Eclipse plugin uses these tags to produce linked \npopup lists which indicate the source and target methods of the \nstatement. Selecting a link from the list moves the cursor to \nthe indicated method. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.parity"))   return "Phase " + phaseName + ":\n"+ "\nThe Parity Tagger produces StringTags and ColorTags indicating \nthe parity of a variable (even, odd, top, or bottom). The \neclipse plugin can use tooltips and variable colouring to \ndisplay the information in these tags. For example, even \nvariables (such as x in x = 2) are coloured yellow. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.pat"))   return "Phase " + phaseName + ":\n"+ "\nFor each method with parameters of reference type, this tagger \nindicates the aliasing relationships between the parameters \nusing colour tags. Parameters that may be aliased are the same \ncolour. Parameters that may not be aliased are in different \ncolours."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.lvtagger"))   return "Phase " + phaseName + ":\n"+ "\nColors live variables."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.rdtagger"))   return "Phase " + phaseName + ":\n"+ "\nFor each use of a local in a stmt creates a link to the reaching \ndef."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.che"))   return "Phase " + phaseName + ":\n"+ "\nIndicates whether cast checks can be eliminated."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.umt"))   return "Phase " + phaseName + ":\n"+ "\nWhen the whole-program analysis determines a method to be \nunreachable, this transformer inserts an assertion into the \nmethod to check that it is indeed unreachable."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.lit"))   return "Phase " + phaseName + ":\n"+ "\nAn expression whose operands are constant or have reaching \ndefinitions from outside the loop body are tagged as loop \ninvariant."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("jap.aet"))   return "Phase " + phaseName + ":\n"+ "\nA each statement a set of available expressions is after the \nstatement is added as a tag."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","")+ padOpt("kind","")+ padVal("optimistic (default)","")+ padVal("pessimistic","");
  if (phaseName.equals("jap.dmt"))   return "Phase " + phaseName + ":\n"+ "\nProvides link tags at a statement to all of the satements \ndominators."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("gb"))   return "Phase " + phaseName + ":\n"+ "\nThe Grimp Body Creation phase creates a GrimpBody for each \nsource method. It is run only if the output format is grimp or \ngrimple, or if class files are being output and the Via Grimp \noption has been specified. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("gb.a1"))   return "Phase " + phaseName + ":\n"+ "\nThe Grimp Pre-folding Aggregator combines some local variables, \nfinding definitions with only a single use and removing the \ndefinition after replacing the use with the definition's \nright-hand side, if it is safe to do so. While the mechanism is \nthe same as that employed by the Jimple Local Aggregator, there \nis more scope for aggregation because of Grimp's more \ncomplicated expressions. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("gb.cf"))   return "Phase " + phaseName + ":\n"+ "\nThe Grimp Constructor Folder combines new statements with the \nspecialinvoke statement that calls the new object's constructor. \nFor example, it turns r2 = new java.util.ArrayList; r2.init(); \ninto r2 = new java.util.ArrayList(); "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("gb.a2"))   return "Phase " + phaseName + ":\n"+ "\nThe Grimp Post-folding Aggregator combines local variables \nafter constructors have been folded. Constructor folding \ntypically introduces new opportunities for aggregation, since \nwhen a sequence of instructions like r2 = new \njava.util.ArrayList; r2.init(); r3 = r2 is replaced by r2 = new \njava.util.ArrayList(); r3 = r2 the invocation of init no longer \nrepresents a potential side-effect separating the two \ndefinitions, so they can be combined into r3 = new \njava.util.ArrayList(); (assuming there are no subsequent uses of \nr2). "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("only-stack-locals (true)","");
  if (phaseName.equals("gb.ule"))   return "Phase " + phaseName + ":\n"+ "\nThis phase removes any locals that are unused after constructor \nfolding and aggregation. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("gop"))   return "Phase " + phaseName + ":\n"+ "\nThe Grimp Optimization pack performs optimizations on \nGrimpBodys (currently there are no optimizations performed \nspecifically on GrimpBodys, and the pack is empty). It is run \nonly if the output format is grimp or grimple, or if class files \nare being output and the Via Grimp option has been specified. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("bb"))   return "Phase " + phaseName + ":\n"+ "\nThe Baf Body Creation phase creates a BafBody from each source \nmethod. It is run if the output format is baf or b, or if class \nfiles are being output and the Via Grimp option has not been \nspecified. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("bb.lso"))   return "Phase " + phaseName + ":\n"+ "\nThe Load Store Optimizer replaces some combinations of loads to \nand stores from local variables with stack instructions. A \nsimple example would be the replacement of store.r $r2; load.r \n$r2; with dup1.r in cases where the value of r2 is not used \nsubsequently. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("debug (false)","")+ padOpt("inter (false)","")+ padOpt("sl (true)","")+ padOpt("sl2 (false)","")+ padOpt("sll (true)","")+ padOpt("sll2 (false)","");
  if (phaseName.equals("bb.pho"))   return "Phase " + phaseName + ":\n"+ "\nApplies peephole optimizations to the Baf intermediate \nrepresentation. Individual optimizations must be implemented by \nclasses implementing the Peephole interface. The Peephole \nOptimizer reads the names of the Peephole classes at runtime \nfrom the file peephole.dat and loads them dynamically. Then it \ncontinues to apply the Peepholes repeatedly until none of them \nare able to perform any further optimizations. Soot provides \nonly one Peephole, named ExamplePeephole, which is not enabled \nby the delivered peephole.dat file. ExamplePeephole removes all \ncheckcast instructions."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("bb.ule"))   return "Phase " + phaseName + ":\n"+ "\nThis phase removes any locals that are unused after load store \noptimization and peephole optimization. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("bb.lp"))   return "Phase " + phaseName + ":\n"+ "\nThe Local Packer attempts to minimize the number of local \nvariables required in a method by reusing the same variable for \ndisjoint DU-UD webs. Conceptually, it is the inverse of the \nLocal Splitter. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("unsplit-original-locals (false)","");
  if (phaseName.equals("bop"))   return "Phase " + phaseName + ":\n"+ "\nThe Baf Optimization pack performs optimizations on BafBodys \n(currently there are no optimizations performed specifically on \nBafBodys, and the pack is empty). It is run only if the output \nformat is baf or b, or if class files are being output and the \nVia Grimp option has not been specified. "+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("tag"))   return "Phase " + phaseName + ":\n"+ "\nThe Tag Aggregator pack aggregates tags attached to individual \nunits into a code attribute for each method, so that these \nattributes can be encoded in Java class files."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("tag.ln"))   return "Phase " + phaseName + ":\n"+ "\nThe Line Number Tag Aggregator aggregates line number tags."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("tag.an"))   return "Phase " + phaseName + ":\n"+ "\nThe Array Bounds and Null Pointer Tag Aggregator aggregates \ntags produced by the Array Bound Checker and Null Pointer \nChecker."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("tag.dep"))   return "Phase " + phaseName + ":\n"+ "\nThe Dependence Tag Aggregator aggregates tags produced by the \nSide Effect Tagger."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("tag.fieldrw"))   return "Phase " + phaseName + ":\n"+ "\nThe Field Read/Write Tag Aggregator aggregates field read/write \ntags produced by the Field Read/Write Tagger, phase jap.fieldrw. \n"+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("db"))   return "Phase " + phaseName + ":\n"+ "\nThe decompile (Dava) option is set using the -f dava options in \nSoot. Options provided by Dava are added to this dummy phase so \nas not to clutter the soot general arguments. -p db (option \nname):(value) will be used to set all required values for Dava. \n"+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","")+ padOpt("source-is-javac (true)","");
  if (phaseName.equals("db.transformations"))   return "Phase " + phaseName + ":\n"+ "\n					The transformations implemented using AST Traversal and \nstructural flow analses on Dava's AST 					"+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("db.renamer"))   return "Phase " + phaseName + ":\n"+ "\nIf set, the renaming analyses implemented in Dava are applied to \neach method body being decompiled. The analyses use heuristics \nto choose potentially better names for local variables. (As of \nFebruary 14th 2006, work is still under progress on these \nanalyses (dava.toolkits.base.renamer). 					"+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (false)","");
  if (phaseName.equals("db.deobfuscate"))   return "Phase " + phaseName + ":\n"+ "\nCertain analyses make sense only when the bytecode is obfuscated \ncode. There are plans to implement such analyses and apply them \non methods only if this flag is set. Dead Code elimination \nwhich includes removing code guarded by some condition which is \nalways false or always true is one such analysis. Another \nsuggested analysis is giving default names to classes and \nfields. Onfuscators love to use weird names for fields and \nclasses and even a simple re-naming of these could be a good \nhelp to the user. Another more advanced analysis would be to \ncheck for redundant constant fields added by obfuscators and \nthen remove uses of these constant fields from the code."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  if (phaseName.equals("db.force-recompile"))   return "Phase " + phaseName + ":\n"+ "\nWhile decompiling we have to be clear what our aim is: do we \nwant to convert bytecode to Java syntax and stay as close to the \nactual execution of bytecode or do we want recompilably Java \nsource representing the bytecode. This distinction is important \nbecause some restrictions present in Java source are absent from \nthe bytecode. Examples of this include that fact that in Java a \ncall to a constructor or super needs to be the first statement \nin a constructors body. This restriction is absent from the \nbytecode. Similarly final fields HAVE to be initialized once and \nonly once in either the static initializer (static fields) or \nall the constructors (non-static fields). Additionally the \nfields should be initialized on all possible execution paths. \nThese restrictions are again absent from the bytecode. In doing \na one-one conversion of bytecode to Java source then no attempt \nshould be made to fix any of these and similar problems in the \nJava source. However, if the aim is to get recompilable code \nthen these and similar issues need to be fixed. Setting the \nforce-recompilability flag will ensure that the decompiler tries \nits best to produce recompilable Java source."+ "\n\nRecognized options (with default values):\n"+ padOpt("enabled (true)","");
  return "Unrecognized phase: " + phaseName;
}
