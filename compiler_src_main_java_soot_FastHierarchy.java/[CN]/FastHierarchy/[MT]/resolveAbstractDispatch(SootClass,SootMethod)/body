{
  String methodSig=m.getSubSignature();
  HashSet<SootClass> resolved=new HashSet<SootClass>();
  HashSet<SootMethod> ret=new HashSet<SootMethod>();
  LinkedList worklist=new LinkedList();
  worklist.add(abstractType);
  while (!worklist.isEmpty()) {
    SootClass concreteType=(SootClass)worklist.removeFirst();
    SootClass savedConcreteType=concreteType;
    if (concreteType.isInterface()) {
      worklist.addAll(getAllImplementersOfInterface(concreteType));
      continue;
    }
    Collection c=classToSubclasses.get(concreteType);
    if (c != null)     worklist.addAll(c);
    if (!concreteType.isAbstract()) {
      while (true) {
        if (resolved.contains(concreteType))         break;
        resolved.add(concreteType);
        if (concreteType.declaresMethod(methodSig)) {
          SootMethod method=concreteType.getMethod(methodSig);
          if (method.isAbstract())           throw new RuntimeException("abstract dispatch resolved to abstract method!\nAbstract Type: " + abstractType + "\nConcrete Type: "+ savedConcreteType+ "\nMethod: "+ m);
          if (isVisible(concreteType,m)) {
            ret.add(concreteType.getMethod(methodSig));
            break;
          }
        }
        if (!concreteType.hasSuperclass())         throw new RuntimeException("could not resolve abstract dispatch!\nAbstract Type: " + abstractType + "\nConcrete Type: "+ savedConcreteType+ "\nMethod: "+ m);
        concreteType=concreteType.getSuperclass();
      }
    }
  }
  return ret;
}
