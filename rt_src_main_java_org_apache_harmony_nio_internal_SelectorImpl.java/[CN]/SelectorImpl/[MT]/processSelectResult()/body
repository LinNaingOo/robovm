{
  if (READABLE == flags[0]) {
    ByteBuffer readbuf=ByteBuffer.allocate(MOCK_READBUF_SIZE);
    while (source.read(readbuf) > 0) {
      readbuf.flip();
    }
  }
  int selected=0;
  for (int i=1; i < flags.length; i++) {
    if (flags[i] == NA) {
      continue;
    }
    SelectionKeyImpl key=i >= readableKeysCount ? keys[writableFDsToKeys[i - readableKeysCount]] : keys[readableFDsToKeys[i]];
    if (null == key) {
      continue;
    }
    int ops=key.interestOpsNoCheck();
    int selectedOp=0;
switch (flags[i]) {
case READABLE:
      selectedOp=ACCEPT_OR_READ & ops;
    break;
case WRITEABLE:
  if (key.isConnected()) {
    selectedOp=OP_WRITE & ops;
  }
 else {
    selectedOp=OP_CONNECT & ops;
  }
break;
}
if (0 != selectedOp) {
boolean wasSelected=mutableSelectedKeys.contains(key);
if (wasSelected && key.readyOps() != selectedOp) {
key.setReadyOps(key.readyOps() | selectedOp);
selected++;
}
 else if (!wasSelected) {
key.setReadyOps(selectedOp);
mutableSelectedKeys.add(key);
selected++;
}
}
}
return selected;
}
