{
  final ServerSocket listener=new ServerSocket(0);
  Hooks cHooks=new Hooks(){
    @Override public int beforeHandshake(    int context) throws SSLException {
      int s=super.beforeHandshake(context);
      NativeCrypto.SSL_clear_mode(s,SSL_MODE_HANDSHAKE_CUTTHROUGH);
      return s;
    }
    @Override public void afterHandshake(    int session,    int s,    int c,    Socket sock,    FileDescriptor fd,    SSLHandshakeCallbacks callback) throws Exception {
      NativeCrypto.SSL_read(s,fd,callback,new byte[1],0,1,0);
      fail();
      super.afterHandshake(session,s,c,sock,fd,callback);
    }
    @Override public void clientCertificateRequested(    int s){
      super.clientCertificateRequested(s);
      throw new RuntimeException("expected");
    }
  }
;
  Hooks sHooks=new ServerHooks(getServerPrivateKey(),getServerCertificates()){
    @Override public void afterHandshake(    int session,    int s,    int c,    Socket sock,    FileDescriptor fd,    SSLHandshakeCallbacks callback) throws Exception {
      NativeCrypto.SSL_set_verify(s,NativeCrypto.SSL_VERIFY_PEER);
      NativeCrypto.SSL_set_options(s,NativeCrypto.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
      NativeCrypto.SSL_renegotiate(s);
      NativeCrypto.SSL_write(s,fd,callback,new byte[]{42},0,1);
      super.afterHandshake(session,s,c,sock,fd,callback);
    }
  }
;
  Future<TestSSLHandshakeCallbacks> client=handshake(listener,0,true,cHooks,null);
  Future<TestSSLHandshakeCallbacks> server=handshake(listener,0,false,sHooks,null);
  server.get(TIMEOUT_SECONDS,TimeUnit.SECONDS);
  try {
    client.get(TIMEOUT_SECONDS,TimeUnit.SECONDS);
  }
 catch (  ExecutionException e) {
    if (!"expected".equals(e.getCause().getMessage())) {
      throw e;
    }
  }
}
