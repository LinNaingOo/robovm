{
class IntComparator implements Comparator {
    public int compare(    Object o1,    Object o2){
      Integer v1=order.get(o1);
      Integer v2=order.get(o2);
      return v1.intValue() - v2.intValue();
    }
  }
  ;
  SortedSet queue=new TreeSet(new IntComparator());
  Iterator it=order.keySet().iterator();
  while (it.hasNext()) {
    Object o=it.next();
    data.put(o,newInitialSummary());
    queue.add(o);
  }
  Map<SootMethod,Integer> nb=new HashMap<SootMethod,Integer>();
  while (!queue.isEmpty()) {
    SootMethod m=(SootMethod)queue.first();
    queue.remove(m);
    Object newSummary=newInitialSummary();
    Object oldSummary=data.get(m);
    if (nb.containsKey(m))     nb.put(m,new Integer(nb.get(m).intValue() + 1));
 else     nb.put(m,new Integer(1));
    if (verbose)     G.v().out.println(" |- processing " + m.toString() + " ("+ nb.get(m)+ "-st time)");
    analyseMethod(m,newSummary);
    if (!oldSummary.equals(newSummary)) {
      data.put(m,newSummary);
      queue.addAll(dg.getPredsOf(m));
    }
  }
  if (doCheck) {
    it=order.keySet().iterator();
    while (it.hasNext()) {
      SootMethod m=(SootMethod)it.next();
      Object newSummary=newInitialSummary();
      Object oldSummary=data.get(m);
      analyseMethod(m,newSummary);
      if (!oldSummary.equals(newSummary)) {
        G.v().out.println("inter-procedural fixpoint not reached for method " + m.toString());
        DotGraph gm=new DotGraph("false_fixpoint");
        DotGraph gmm=new DotGraph("next_iterate");
        gm.setGraphLabel("false fixpoint: " + m.toString());
        gmm.setGraphLabel("fixpoint next iterate: " + m.toString());
        fillDotGraph("",oldSummary,gm);
        fillDotGraph("",newSummary,gmm);
        gm.plot(m.toString() + "_false_fixpoint.dot");
        gmm.plot(m.toString() + "_false_fixpoint_next.dot");
        throw new Error("AbstractInterproceduralAnalysis sanity check failed!!!");
      }
    }
  }
}
