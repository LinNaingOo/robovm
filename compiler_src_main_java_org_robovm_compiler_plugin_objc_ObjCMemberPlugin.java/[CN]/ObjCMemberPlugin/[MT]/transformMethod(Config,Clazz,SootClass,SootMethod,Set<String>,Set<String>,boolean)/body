{
  AnnotationTag methodAnno=getAnnotation(method,METHOD);
  if (methodAnno != null) {
    if (extensions && !(method.isStatic() && method.isNative())) {
      throw new CompilerException("Objective-C @Method method " + method + " in extension class must be static and native.");
    }
    String selectorName=readStringElem(methodAnno,"selector","").trim();
    if (selectorName.length() == 0) {
      StringBuilder sb=new StringBuilder(method.getName());
      int argCount=method.getParameterCount();
      for (int i=extensions ? 1 : 0; i < argCount; i++) {
        sb.append(':');
      }
      selectorName=sb.toString();
    }
    if (!extensions && (method.getModifiers() & Modifier.FINAL) == 0) {
      Type receiverType=ObjCProtocolProxyPlugin.isObjCProxy(sootClass) ? sootClass.getInterfaces().getFirst().getType() : sootClass.getType();
      createCallback(sootClass,method,selectorName,receiverType);
    }
    if (method.isNative()) {
      if (checkOverridable(overridables,selectorName,method)) {
        overridables.add(selectorName);
      }
      selectors.add(selectorName);
      createBridge(sootClass,method,selectorName,false,extensions);
    }
  }
 else {
    AnnotationTag propertyAnno=getAnnotation(method,PROPERTY);
    if (propertyAnno != null) {
      if (extensions && !(method.isStatic() && method.isNative())) {
        throw new CompilerException("Objective-C @Property method " + method + " in extension class must be static and native.");
      }
      int getterParamCount=extensions ? 1 : 0;
      int setterParamCount=extensions ? 2 : 1;
      if (method.getReturnType() != VoidType.v() && method.getParameterCount() != getterParamCount || method.getReturnType() == VoidType.v() && method.getParameterCount() != setterParamCount) {
        if (!extensions) {
          throw new CompilerException("Objective-C @Property method " + method + " does not have a supported signature. @Property getter methods"+ " must take 0 arguments and must not return void. "+ "@Property setter methods must take 1 argument and return void.");
        }
        throw new CompilerException("Objective-C @Property method " + method + " in extension class"+ " does not have a supported signature. @Property getter methods in extension classes"+ " must take 1 argument (the 'this' reference) and must not return void. "+ "@Property setter methods in extension classes must "+ "take 2 arguments (first is the 'this' reference) and return void.");
      }
      boolean isGetter=method.getReturnType() != VoidType.v();
      String selectorName=readStringElem(propertyAnno,"selector","").trim();
      if (selectorName.length() == 0) {
        String methodName=method.getName();
        if (!(isGetter && methodName.startsWith("get") && methodName.length() > 3) && !(isGetter && methodName.startsWith("is") && methodName.length() > 2) && !(!isGetter && methodName.startsWith("set") && methodName.length() > 3)) {
          throw new CompilerException("Invalid Objective-C @Property method name " + method + ". @Property methods without an explicit selector value "+ "must follow the Java beans property method naming convention.");
        }
        selectorName=methodName;
        if (isGetter) {
          selectorName=methodName.startsWith("is") ? methodName.substring(2) : methodName.substring(3);
          selectorName=selectorName.substring(0,1).toLowerCase() + selectorName.substring(1);
        }
 else {
          selectorName+=":";
        }
      }
      if (!extensions && (method.getModifiers() & Modifier.FINAL) == 0) {
        Type receiverType=ObjCProtocolProxyPlugin.isObjCProxy(sootClass) ? sootClass.getInterfaces().getFirst().getType() : sootClass.getType();
        createCallback(sootClass,method,selectorName,receiverType);
      }
      if (method.isNative()) {
        if (checkOverridable(overridables,selectorName,method)) {
          overridables.add(selectorName);
        }
        selectors.add(selectorName);
        boolean strongRefSetter=!isGetter && readBooleanElem(propertyAnno,"strongRef",false);
        createBridge(sootClass,method,selectorName,strongRefSetter,extensions);
      }
    }
  }
}
