{
  int cbRemaining=cb.remaining();
  if (CharsetProviderImpl.hasLoadedNatives() && bb.isDirect() && bb.hasRemaining()&& cb.hasArray()) {
    int toProceed=bb.remaining();
    int cbPos=cb.position();
    int bbPos=bb.position();
    boolean throwOverflow=false;
    if (cbRemaining < toProceed) {
      toProceed=cbRemaining;
      throwOverflow=true;
    }
    int res=nDecode(cb.array(),cb.arrayOffset() + cbPos,toProceed,AddressUtil.getDirectBufferAddress(bb),bbPos);
    bb.position(bbPos + res);
    cb.position(cbPos + res);
    if (throwOverflow)     return CoderResult.OVERFLOW;
  }
 else {
    if (bb.hasArray() && cb.hasArray()) {
      int rem=bb.remaining();
      rem=cbRemaining >= rem ? rem : cbRemaining;
      byte[] bArr=bb.array();
      char[] cArr=cb.array();
      int bStart=bb.position();
      int cStart=cb.position();
      int i;
      for (i=bStart; i < bStart + rem; i++) {
        char in=(char)(bArr[i] & 0xFF);
        if (in >= 26) {
          int index=(int)in - 26;
          cArr[cStart++]=(char)arr[index];
        }
 else {
          cArr[cStart++]=(char)(in & 0xFF);
        }
      }
      bb.position(i);
      cb.position(cStart);
      if (rem == cbRemaining && bb.hasRemaining())       return CoderResult.OVERFLOW;
    }
 else {
      while (bb.hasRemaining()) {
        if (cbRemaining == 0)         return CoderResult.OVERFLOW;
        char in=(char)(bb.get() & 0xFF);
        if (in >= 26) {
          int index=(int)in - 26;
          cb.put(arr[index]);
        }
 else {
          cb.put((char)(in & 0xFF));
        }
        cbRemaining--;
      }
    }
  }
  return CoderResult.UNDERFLOW;
}
