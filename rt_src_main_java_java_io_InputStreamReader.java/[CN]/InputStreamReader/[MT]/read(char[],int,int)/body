{
synchronized (lock) {
    if (!isOpen()) {
      throw new IOException(Messages.getString("luni.BA"));
    }
    if (offset < 0 || offset > buf.length - length || length < 0) {
      throw new IndexOutOfBoundsException();
    }
    if (length == 0) {
      return 0;
    }
    CharBuffer out=CharBuffer.wrap(buf,offset,length);
    CoderResult result=CoderResult.UNDERFLOW;
    boolean needInput=!bytes.hasRemaining();
    while (out.hasRemaining()) {
      if (needInput) {
        try {
          if ((in.available() == 0) && (out.position() > offset)) {
            break;
          }
        }
 catch (        IOException e) {
        }
        int to_read=bytes.capacity() - bytes.limit();
        int off=bytes.arrayOffset() + bytes.limit();
        int was_red=in.read(bytes.array(),off,to_read);
        if (was_red == -1) {
          endOfInput=true;
          break;
        }
 else         if (was_red == 0) {
          break;
        }
        bytes.limit(bytes.limit() + was_red);
        needInput=false;
      }
      result=decoder.decode(bytes,out,false);
      if (result.isUnderflow()) {
        if (bytes.limit() == bytes.capacity()) {
          bytes.compact();
          bytes.limit(bytes.position());
          bytes.position(0);
        }
        needInput=true;
      }
 else {
        break;
      }
    }
    if (result == CoderResult.UNDERFLOW && endOfInput) {
      result=decoder.decode(bytes,out,true);
      decoder.flush(out);
      decoder.reset();
    }
    if (result.isMalformed()) {
      throw new MalformedInputException(result.length());
    }
 else     if (result.isUnmappable()) {
      throw new UnmappableCharacterException(result.length());
    }
    return out.position() - offset == 0 ? -1 : out.position() - offset;
  }
}
