{
  File outFile=new File(output,target);
  if (verbose) {
    stdout.format("Building executable '%s'\n",outFile);
  }
  Module module=new Module();
  List<Value> bootcpValues=new ArrayList<Value>();
  List<Value> cpValues=new ArrayList<Value>();
  Set<String> seenClasses=new HashSet<String>();
  for (  ClasspathEntry entry : entries) {
    for (    Clazz c : entry.getPath().list()) {
      if (seenClasses.contains(c.getInternalName())) {
        continue;
      }
      seenClasses.add(c.getInternalName());
      byte[] modUtf8=SootClassCompiler.stringToModifiedUtf8(c.getInternalName());
      Global var=new Global(SootClassCompiler.getStringVarName(modUtf8),Linkage.linker_private_weak,new StringConstant(modUtf8),true);
      module.addGlobal(var);
      String funcName="NullVM_" + SootClassCompiler.mangleString(c.getInternalName());
      FunctionDeclaration func=new FunctionDeclaration(funcName,new FunctionType(Type.I8_PTR,Type.I8_PTR,Type.I8_PTR,Type.I8_PTR));
      module.addFunctionDeclaration(func);
      Value value=new StructureConstant(new StructureType(Type.I8_PTR,Type.I8_PTR),new ConstantGetelementptr(var.ref(),0,0),new ConstantBitcast(func.ref(),Type.I8_PTR));
      if (entry.isInBootClasspath()) {
        bootcpValues.add(value);
      }
 else {
        cpValues.add(value);
      }
    }
  }
  bootcpValues.add(new StructureConstant(new StructureType(Type.I8_PTR,Type.I8_PTR),new NullConstant(Type.I8_PTR),new NullConstant(Type.I8_PTR)));
  cpValues.add(new StructureConstant(new StructureType(Type.I8_PTR,Type.I8_PTR),new NullConstant(Type.I8_PTR),new NullConstant(Type.I8_PTR)));
  Global gbcp=module.newGlobal(new ArrayConstant(new ArrayType(bootcpValues.size(),new StructureType(Type.I8_PTR,Type.I8_PTR)),bootcpValues.toArray(new Value[0])),true);
  module.addGlobal(new Global("_nvmBcBootclasspathEntries",new ConstantGetelementptr(gbcp.ref(),0,0)));
  Global gcp=module.newGlobal(new ArrayConstant(new ArrayType(cpValues.size(),new StructureType(Type.I8_PTR,Type.I8_PTR)),cpValues.toArray(new Value[0])),true);
  module.addGlobal(new Global("_nvmBcClasspathEntries",new ConstantGetelementptr(gcp.ref(),0,0)));
  if (mainClass != null) {
    Global g=module.newGlobal(new StringConstant(SootClassCompiler.stringToModifiedUtf8(mainClass)),true);
    module.addGlobal(new Global("_nvmBcMainClass",new ConstantGetelementptr(g.ref(),0,0)));
  }
  File configLl=new File(tmpFile,"config.ll");
  FileUtils.writeStringToFile(configLl,module.toString(),"UTF-8");
  File configS=new File(tmpFile,"config.s");
  llc(configLl,configS);
  String gccPath="gcc";
  if (gccBin != null) {
    gccPath=gccBin.getAbsolutePath();
  }
  List<String> gccArgs=new ArrayList<String>();
  List<String> libArgs=new ArrayList<String>();
  libArgs.addAll(Arrays.asList("-lm","-lnullvm-core","-lnullvm-bc","-lnullvm-hyprt"));
  gccArgs.add("-L");
  gccArgs.add(homeLibOsArch.getAbsolutePath());
  gccArgs.add("-Xlinker");
  gccArgs.add("--gc-sections");
  if (os == OS.linux) {
    libArgs.add("-l:libgc.so.1");
    gccArgs.add("-Xlinker");
    gccArgs.add("-rpath=$ORIGIN");
  }
  if (os == OS.darwin) {
    libArgs.add("-lgc");
    File unexportedSymbolsFile=new File(tmpFile,"unexported_symbols");
    FileUtils.writeStringToFile(unexportedSymbolsFile,"*\n","ASCII");
    gccArgs.add("-unexported_symbols_list");
    gccArgs.add(unexportedSymbolsFile.getAbsolutePath());
    gccArgs.add("-Xlinker");
    gccArgs.add("-no_compact_unwind");
    gccArgs.add("-arch");
    gccArgs.add(arch.toString());
  }
  exec(gccPath,"-o",outFile,"-g",gccOpts,gccArgs,configS,libFiles,libArgs);
}
