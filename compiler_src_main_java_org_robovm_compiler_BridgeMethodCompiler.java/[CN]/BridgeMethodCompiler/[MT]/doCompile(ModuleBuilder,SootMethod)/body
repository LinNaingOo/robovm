{
  validateBridgeMethod(method);
  Function outerFn=FunctionBuilder.method(method);
  moduleBuilder.addFunction(outerFn);
  Function innerFn=FunctionBuilder.bridgeInner(method);
  moduleBuilder.addFunction(innerFn);
  Type[] parameterTypes=innerFn.getType().getParameterTypes();
  String[] parameterNames=innerFn.getParameterNames();
  ArrayList<Argument> args=new ArrayList<Argument>();
  for (int i=0; i < parameterTypes.length; i++) {
    args.add(new Argument(new VariableRef(parameterNames[i],parameterTypes[i])));
  }
  Value resultOuter=callWithArguments(outerFn,innerFn.ref(),args);
  outerFn.add(new Ret(resultOuter));
  FunctionType targetFnType=getBridgeFunctionType(method);
  Variable targetFn=innerFn.newVariable(targetFnType);
  Global targetFnPtr=new Global(getTargetFnPtrName(method),_private,new NullConstant(I8_PTR));
  moduleBuilder.addGlobal(targetFnPtr);
  innerFn.add(new Load(targetFn,new ConstantBitcast(targetFnPtr.ref(),new PointerType(targetFnType))));
  Label nullLabel=new Label();
  Label notNullLabel=new Label();
  Variable nullCheck=innerFn.newVariable(I1);
  innerFn.add(new Icmp(nullCheck,Condition.eq,targetFn.ref(),new NullConstant(targetFnType)));
  innerFn.add(new Br(nullCheck.ref(),innerFn.newBasicBlockRef(nullLabel),innerFn.newBasicBlockRef(notNullLabel)));
  innerFn.newBasicBlock(nullLabel);
  call(innerFn,BC_THROW_UNSATISIFED_LINK_ERROR,innerFn.getParameterRef(0),moduleBuilder.getString(String.format("Bridge method %s.%s%s not bound",className,method.getName(),getDescriptor(method))));
  innerFn.add(new Unreachable());
  innerFn.newBasicBlock(notNullLabel);
  args.remove(0);
  if (!method.isStatic()) {
    args.remove(0);
  }
class MarshaledValue {
    private Value object;
    private Value handle;
    private String marshalerClassName;
  }
  List<MarshaledValue> marshaledValues=new ArrayList<MarshaledValue>();
  Type[] targetParameterTypes=targetFnType.getParameterTypes();
  for (int i=0; i < sootMethod.getParameterCount(); i++) {
    soot.Type type=sootMethod.getParameterType(i);
    if (needsMarshaler(type)) {
      ParameterAttribute[] parameterAttributes=new ParameterAttribute[0];
      if (isPassByValue(method,i) || isStructRet(method,i)) {
        call(innerFn,CHECK_NULL,innerFn.getParameterRef(0),args.get(i).getValue());
        parameterAttributes=new ParameterAttribute[1];
        if (isStructRet(method,i)) {
          parameterAttributes[0]=sret;
        }
 else {
          parameterAttributes[0]=byval;
        }
      }
      MarshaledValue marshaledValue=new MarshaledValue();
      marshaledValues.add(marshaledValue);
      marshaledValue.object=args.get(i).getValue();
      String marshalerClassName=getMarshalerClassName(method,i);
      Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),marshalerClassName,"toNative","(Ljava/lang/Object;)J");
      trampolines.add(invokestatic);
      Value argI64=call(innerFn,invokestatic.getFunctionRef(),innerFn.getParameterRef(0),args.get(i).getValue());
      marshaledValue.marshalerClassName=marshalerClassName;
      marshaledValue.handle=argI64;
      Variable arg=innerFn.newVariable(targetParameterTypes[i]);
      innerFn.add(new Inttoptr(arg,argI64,arg.getType()));
      args.set(i,new Argument(arg.ref(),parameterAttributes));
    }
 else     if (hasPointerAnnotation(method,i)) {
      Variable arg=innerFn.newVariable(I8_PTR);
      innerFn.add(new Inttoptr(arg,args.get(i).getValue(),I8_PTR));
      args.set(i,new Argument(arg.ref()));
    }
  }
  pushNativeFrame(innerFn);
  Value resultInner=callWithArguments(innerFn,targetFn.ref(),args);
  popNativeFrame(innerFn);
  for (  MarshaledValue value : marshaledValues) {
    Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),value.marshalerClassName,"updateObject","(Ljava/lang/Object;J)V");
    trampolines.add(invokestatic);
    call(innerFn,invokestatic.getFunctionRef(),innerFn.getParameterRef(0),value.object,value.handle);
  }
  if (needsMarshaler(method.getReturnType())) {
    Value copy=new IntegerConstant((byte)0);
    if (isPassByValue(method)) {
      Variable stackCopy=innerFn.newVariable(new PointerType(targetFnType.getReturnType()));
      innerFn.add(new Alloca(stackCopy,targetFnType.getReturnType()));
      innerFn.add(new Store(resultInner,stackCopy.ref()));
      resultInner=stackCopy.ref();
      copy=new IntegerConstant((byte)1);
    }
    String targetClassName=getInternalName(method.getReturnType());
    FunctionRef ldcClassFn=null;
    if (targetClassName.equals(this.className)) {
      ldcClassFn=FunctionBuilder.ldcInternal(method.getDeclaringClass()).ref();
    }
 else {
      Trampoline trampoline=new LdcClass(className,targetClassName);
      trampolines.add(trampoline);
      ldcClassFn=trampoline.getFunctionRef();
    }
    Value returnClass=call(innerFn,ldcClassFn,innerFn.getParameterRef(0));
    String marshalerClassName=getMarshalerClassName(method);
    Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),marshalerClassName,"toObject","(Ljava/lang/Class;JZ)Ljava/lang/Object;");
    trampolines.add(invokestatic);
    Variable resultI64=innerFn.newVariable(I64);
    innerFn.add(new Ptrtoint(resultI64,resultInner,I64));
    resultInner=call(innerFn,invokestatic.getFunctionRef(),innerFn.getParameterRef(0),returnClass,resultI64.ref(),copy);
  }
 else   if (hasPointerAnnotation(method)) {
    Variable resultI64=innerFn.newVariable(I64);
    innerFn.add(new Ptrtoint(resultI64,resultInner,I64));
    resultInner=resultI64.ref();
  }
  innerFn.add(new Ret(resultInner));
}
