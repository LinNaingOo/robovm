{
  validateBridgeMethod(method);
  Function outerFn=FunctionBuilder.method(method);
  moduleBuilder.addFunction(outerFn);
  Type[] parameterTypes=outerFn.getType().getParameterTypes();
  String[] parameterNames=outerFn.getParameterNames();
  ArrayList<Argument> args=new ArrayList<Argument>();
  for (int i=0; i < parameterTypes.length; i++) {
    args.add(new Argument(new VariableRef(parameterNames[i],parameterTypes[i])));
  }
  SootMethod originalMethod=method;
  if (isPassByValue(originalMethod)) {
    Arch arch=config.getArch();
    OS os=config.getOs();
    String triple=config.getTriple();
    if (getStructType(originalMethod.getReturnType()).getAllocSize(triple) > os.getMaxRegisterReturnSize(arch)) {
      method=createFakeStructRetMethod(method);
      VariableRef env=outerFn.getParameterRef(0);
      LdcClass ldcClass=new LdcClass(getInternalName(method.getDeclaringClass()),getInternalName(originalMethod.getReturnType()));
      trampolines.add(ldcClass);
      Value cls=call(outerFn,ldcClass.getFunctionRef(),env);
      Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),"org/robovm/rt/bro/Struct","allocate","(Ljava/lang/Class;)Lorg/robovm/rt/bro/Struct;");
      trampolines.add(invokestatic);
      Value structObj=call(outerFn,invokestatic.getFunctionRef(),env,cls);
      args.add(1,new Argument(structObj));
    }
  }
  Function innerFn=FunctionBuilder.bridgeInner(method);
  moduleBuilder.addFunction(innerFn);
  Value resultOuter=callWithArguments(outerFn,innerFn.ref(),args);
  if (method != originalMethod) {
    outerFn.add(new Ret(args.get(1).getValue()));
  }
 else {
    outerFn.add(new Ret(resultOuter));
  }
  parameterTypes=innerFn.getType().getParameterTypes();
  parameterNames=innerFn.getParameterNames();
  args=new ArrayList<Argument>();
  for (int i=0; i < parameterTypes.length; i++) {
    args.add(new Argument(new VariableRef(parameterNames[i],parameterTypes[i])));
  }
  FunctionType targetFnType=getBridgeFunctionType(method);
  Variable targetFn=innerFn.newVariable(targetFnType);
  Global targetFnPtr=new Global(getTargetFnPtrName(originalMethod),_private,new NullConstant(I8_PTR));
  moduleBuilder.addGlobal(targetFnPtr);
  innerFn.add(new Load(targetFn,new ConstantBitcast(targetFnPtr.ref(),new PointerType(targetFnType))));
  Label nullLabel=new Label();
  Label notNullLabel=new Label();
  Variable nullCheck=innerFn.newVariable(I1);
  innerFn.add(new Icmp(nullCheck,Condition.eq,targetFn.ref(),new NullConstant(targetFnType)));
  innerFn.add(new Br(nullCheck.ref(),innerFn.newBasicBlockRef(nullLabel),innerFn.newBasicBlockRef(notNullLabel)));
  innerFn.newBasicBlock(nullLabel);
  VariableRef env=innerFn.getParameterRef(0);
  call(innerFn,BC_THROW_UNSATISIFED_LINK_ERROR,env,moduleBuilder.getString(String.format("Bridge method %s.%s%s not bound",className,originalMethod.getName(),getDescriptor(originalMethod))));
  innerFn.add(new Unreachable());
  innerFn.newBasicBlock(notNullLabel);
  args.remove(0);
  if (!method.isStatic()) {
    args.remove(0);
  }
  List<MarshaledArg> marshaledArgs=new ArrayList<MarshaledArg>();
  Type[] targetParameterTypes=targetFnType.getParameterTypes();
  for (int i=0; i < method.getParameterCount(); i++) {
    soot.Type type=method.getParameterType(i);
    if (needsMarshaler(type)) {
      String marshalerClassName=getMarshalerClassName(method,i,false);
      Type nativeType=targetParameterTypes[i];
      if (nativeType instanceof PrimitiveType) {
        if (isEnum(type)) {
          Value nativeValue=marshalEnumObjectToNative(innerFn,marshalerClassName,nativeType,env,args.get(i).getValue());
          args.set(i,new Argument(nativeValue));
        }
 else {
          Value nativeValue=marshalValueObjectToNative(innerFn,marshalerClassName,nativeType,env,args.get(i).getValue());
          args.set(i,new Argument(nativeValue));
        }
      }
 else {
        ParameterAttribute[] parameterAttributes=new ParameterAttribute[0];
        if (isPassByValue(method,i) || isStructRet(method,i)) {
          call(innerFn,CHECK_NULL,env,args.get(i).getValue());
          parameterAttributes=new ParameterAttribute[1];
          if (isStructRet(method,i)) {
            parameterAttributes[0]=sret;
          }
 else {
            parameterAttributes[0]=byval;
          }
        }
        MarshaledArg marshaledArg=new MarshaledArg();
        marshaledArg.paramIndex=i;
        marshaledArgs.add(marshaledArg);
        Value nativeValue=marshalObjectToNative(innerFn,marshalerClassName,marshaledArg,nativeType,env,args.get(i).getValue());
        args.set(i,new Argument(nativeValue,parameterAttributes));
      }
    }
 else     if (hasPointerAnnotation(method,i)) {
      args.set(i,new Argument(marshalLongToPointer(innerFn,args.get(i).getValue())));
    }
  }
  BasicBlockRef bbSuccess=innerFn.newBasicBlockRef(new Label("success"));
  BasicBlockRef bbFailure=innerFn.newBasicBlockRef(new Label("failure"));
  pushNativeFrame(innerFn);
  trycatchAllEnter(innerFn,env,bbSuccess,bbFailure);
  innerFn.newBasicBlock(bbSuccess.getLabel());
  Value resultInner=callWithArguments(innerFn,targetFn.ref(),args);
  trycatchLeave(innerFn,env);
  popNativeFrame(innerFn);
  for (  MarshaledArg value : marshaledArgs) {
    soot.Type type=method.getParameterType(value.paramIndex);
    String marshalerClassName=getMarshalerClassName(method,value.paramIndex,true);
    if (isPtr(type)) {
      SootClass sootPtrTargetClass=getPtrTargetClass(method,value.paramIndex);
      Value ptrTargetClass=ldcClass(innerFn,getInternalName(sootPtrTargetClass),env);
      int ptrWrapCount=getPtrWrapCount(method,value.paramIndex);
      Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),marshalerClassName,"updatePtr","(Lorg/robovm/rt/bro/ptr/Ptr;Ljava/lang/Class;JI)V");
      trampolines.add(invokestatic);
      call(innerFn,invokestatic.getFunctionRef(),env,value.object,ptrTargetClass,value.handle,new IntegerConstant(ptrWrapCount));
    }
 else {
      Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),marshalerClassName,"updateObject","(Ljava/lang/Object;J)V");
      trampolines.add(invokestatic);
      call(innerFn,invokestatic.getFunctionRef(),env,value.object,value.handle);
    }
  }
  if (needsMarshaler(method.getReturnType())) {
    String marshalerClassName=getMarshalerClassName(method,true);
    String targetClassName=getInternalName(method.getReturnType());
    if (targetFnType.getReturnType() instanceof PrimitiveType) {
      if (isEnum(method.getReturnType())) {
        resultInner=marshalNativeToEnumObject(innerFn,marshalerClassName,env,targetClassName,resultInner);
      }
 else {
        resultInner=marshalNativeToValueObject(innerFn,marshalerClassName,env,targetClassName,resultInner);
      }
    }
 else {
      if (isPtr(method.getReturnType())) {
        resultInner=marshalNativeToPtr(innerFn,marshalerClassName,null,env,getPtrTargetClass(method),resultInner,getPtrWrapCount(method));
      }
 else {
        resultInner=marshalNativeToObject(innerFn,marshalerClassName,null,env,targetClassName,resultInner,isPassByValue(method));
      }
    }
  }
 else   if (hasPointerAnnotation(method)) {
    resultInner=marshalPointerToLong(innerFn,resultInner);
  }
  innerFn.add(new Ret(resultInner));
  innerFn.newBasicBlock(bbFailure.getLabel());
  trycatchLeave(innerFn,env);
  popNativeFrame(innerFn);
  call(innerFn,BC_THROW_IF_EXCEPTION_OCCURRED,env);
  innerFn.add(new Unreachable());
}
