{
  validateBridgeMethod(method);
  AnnotationTag bridgeAnnotation=getAnnotation(method,BRIDGE);
  boolean dynamic=readBooleanElem(bridgeAnnotation,"dynamic",false);
  boolean optional=readBooleanElem(bridgeAnnotation,"optional",false);
  Function fn=FunctionBuilder.method(method);
  moduleBuilder.addFunction(fn);
  Type[] parameterTypes=fn.getType().getParameterTypes();
  String[] parameterNames=fn.getParameterNames();
  ArrayList<Argument> args=new ArrayList<Argument>();
  for (int i=0; i < parameterTypes.length; i++) {
    args.add(new Argument(new VariableRef(parameterNames[i],parameterTypes[i])));
  }
  SootMethod originalMethod=method;
  Value structObj=null;
  boolean passByValue=isPassByValue(originalMethod);
  DataLayout dataLayout=config.getDataLayout();
  if (passByValue) {
    Arch arch=config.getArch();
    OS os=config.getOs();
    int size=dataLayout.getAllocSize(getStructType(originalMethod.getReturnType()));
    if (!os.isReturnedInRegisters(arch,size)) {
      method=createFakeStructRetMethod(method);
      VariableRef env=fn.getParameterRef(0);
      LdcClass ldcClass=new LdcClass(getInternalName(method.getDeclaringClass()),getInternalName(originalMethod.getReturnType()));
      trampolines.add(ldcClass);
      Value cls=call(fn,ldcClass.getFunctionRef(),env);
      Invokestatic invokestatic=new Invokestatic(getInternalName(method.getDeclaringClass()),"org/robovm/rt/bro/Struct","allocate","(Ljava/lang/Class;)Lorg/robovm/rt/bro/Struct;");
      trampolines.add(invokestatic);
      structObj=call(fn,invokestatic.getFunctionRef(),env,cls);
      args.add(1,new Argument(structObj));
    }
  }
  FunctionType targetFnType=getBridgeFunctionType(method,dynamic);
  if (method == originalMethod && passByValue) {
    int size=dataLayout.getAllocSize(targetFnType.getReturnType());
    Type t=size <= 1 ? I8 : (size <= 2 ? I16 : (size <= 4 ? I32 : I64));
    targetFnType=new FunctionType(t,targetFnType.isVarargs(),targetFnType.getParameterTypes());
  }
  VariableRef env=fn.getParameterRef(0);
  Variable targetFn=fn.newVariable(targetFnType);
  if (!dynamic) {
    Global targetFnPtr=new Global(Symbols.bridgePtrSymbol(originalMethod),_private,new NullConstant(I8_PTR));
    moduleBuilder.addGlobal(targetFnPtr);
    fn.add(new Load(targetFn,new ConstantBitcast(targetFnPtr.ref(),new PointerType(targetFnType))));
    Label nullLabel=new Label();
    Label notNullLabel=new Label();
    Variable nullCheck=fn.newVariable(I1);
    fn.add(new Icmp(nullCheck,Condition.eq,targetFn.ref(),new NullConstant(targetFnType)));
    fn.add(new Br(nullCheck.ref(),fn.newBasicBlockRef(nullLabel),fn.newBasicBlockRef(notNullLabel)));
    fn.newBasicBlock(nullLabel);
    call(fn,BC_THROW_UNSATISIFED_LINK_ERROR,env,moduleBuilder.getString(String.format((optional ? "Optional " : "") + "@Bridge method %s.%s%s not bound",className,originalMethod.getName(),getDescriptor(originalMethod))));
    fn.add(new Unreachable());
    fn.newBasicBlock(notNullLabel);
  }
 else {
    fn.add(new Inttoptr(targetFn,fn.getParameterRef(1),targetFn.getType()));
    args.remove(originalMethod == method ? 1 : 2);
  }
  args.remove(0);
  List<MarshaledArg> marshaledArgs=new ArrayList<MarshaledArg>();
  Type[] targetParameterTypes=targetFnType.getParameterTypes();
  int receiverIdx=-1;
  if (!method.isStatic()) {
    MarshalerMethod marshalerMethod=config.getMarshalerLookup().findMarshalerMethod(new MarshalSite(method,MarshalSite.RECEIVER));
    MarshaledArg marshaledArg=new MarshaledArg();
    marshaledArg.paramIndex=MarshalSite.RECEIVER;
    marshaledArgs.add(marshaledArg);
    receiverIdx=method == originalMethod ? 0 : 1;
    Type nativeType=targetParameterTypes[receiverIdx];
    Value nativeValue=marshalObjectToNative(fn,marshalerMethod,marshaledArg,nativeType,env,args.get(receiverIdx).getValue(),MarshalerFlags.CALL_TYPE_BRIDGE);
    args.set(receiverIdx,new Argument(nativeValue));
  }
  for (int i=0, argIdx=0; i < method.getParameterCount(); i++) {
    if (dynamic && (method == originalMethod && i == 0 || method != originalMethod && i == 1)) {
      continue;
    }
    if (argIdx == receiverIdx) {
      argIdx++;
    }
    soot.Type type=method.getParameterType(i);
    if (needsMarshaler(type)) {
      MarshalerMethod marshalerMethod=config.getMarshalerLookup().findMarshalerMethod(new MarshalSite(method,i));
      Type nativeType=targetParameterTypes[argIdx];
      if (nativeType instanceof PrimitiveType) {
        Value nativeValue=marshalValueObjectToNative(fn,marshalerMethod,nativeType,env,args.get(argIdx).getValue(),MarshalerFlags.CALL_TYPE_BRIDGE);
        args.set(argIdx,new Argument(nativeValue));
      }
 else {
        ParameterAttribute[] parameterAttributes=new ParameterAttribute[0];
        if (isPassByValue(method,i) || isStructRet(method,i)) {
          call(fn,CHECK_NULL,env,args.get(argIdx).getValue());
          if (isStructRet(method,i)) {
            parameterAttributes=new ParameterAttribute[1];
            parameterAttributes[0]=sret;
          }
 else           if (nativeType instanceof PointerType) {
            parameterAttributes=new ParameterAttribute[1];
            parameterAttributes[0]=byval;
          }
        }
        MarshaledArg marshaledArg=new MarshaledArg();
        marshaledArg.paramIndex=i;
        marshaledArgs.add(marshaledArg);
        Value nativeValue=marshalObjectToNative(fn,marshalerMethod,marshaledArg,nativeType,env,args.get(argIdx).getValue(),MarshalerFlags.CALL_TYPE_BRIDGE);
        args.set(argIdx,new Argument(nativeValue,parameterAttributes));
      }
    }
 else {
      args.set(argIdx,new Argument(marshalPrimitiveToNative(fn,method,i,args.get(argIdx).getValue())));
    }
    argIdx++;
  }
  BasicBlockRef bbSuccess=fn.newBasicBlockRef(new Label("success"));
  BasicBlockRef bbFailure=fn.newBasicBlockRef(new Label("failure"));
  pushNativeFrame(fn);
  trycatchAllEnter(fn,env,bbSuccess,bbFailure);
  fn.newBasicBlock(bbSuccess.getLabel());
  Value result=callWithArguments(fn,targetFn.ref(),args);
  trycatchLeave(fn,env);
  popNativeFrame(fn);
  updateObject(method,fn,env,MarshalerFlags.CALL_TYPE_BRIDGE,marshaledArgs);
  if (needsMarshaler(method.getReturnType())) {
    MarshalerMethod marshalerMethod=config.getMarshalerLookup().findMarshalerMethod(new MarshalSite(method));
    String targetClassName=getInternalName(method.getReturnType());
    if (passByValue) {
      Value stackCopy=createStackCopy(fn,result);
      Variable src=fn.newVariable(I8_PTR);
      fn.add(new Bitcast(src,stackCopy,I8_PTR));
      Value heapCopy=call(fn,BC_COPY_STRUCT,env,src.ref(),new IntegerConstant(dataLayout.getAllocSize(result.getType())));
      result=marshalNativeToObject(fn,marshalerMethod,null,env,targetClassName,heapCopy,MarshalerFlags.CALL_TYPE_BRIDGE);
    }
 else     if (targetFnType.getReturnType() instanceof PrimitiveType) {
      result=marshalNativeToValueObject(fn,marshalerMethod,env,targetClassName,result,MarshalerFlags.CALL_TYPE_BRIDGE);
    }
 else {
      result=marshalNativeToObject(fn,marshalerMethod,null,env,targetClassName,result,MarshalerFlags.CALL_TYPE_BRIDGE);
    }
  }
 else {
    result=marshalNativeToPrimitive(fn,method,result);
  }
  if (method != originalMethod) {
    fn.add(new Ret(structObj));
  }
 else {
    fn.add(new Ret(result));
  }
  fn.newBasicBlock(bbFailure.getLabel());
  trycatchLeave(fn,env);
  popNativeFrame(fn);
  Value ex=call(fn,BC_EXCEPTION_CLEAR,env);
  updateObject(method,fn,env,MarshalerFlags.CALL_TYPE_BRIDGE,marshaledArgs);
  call(fn,BC_THROW,env,ex);
  fn.add(new Unreachable());
  return fn;
}
