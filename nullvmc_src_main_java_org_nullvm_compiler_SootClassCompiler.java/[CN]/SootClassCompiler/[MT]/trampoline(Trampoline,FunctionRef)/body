{
  String name=functionRef.getName().substring(1);
  GlobalRef ptr=new GlobalRef(name + "_ptr",functionRef.getType());
  Type[] parameterTypes=functionRef.getType().getParameterTypes();
  String[] parameterNames=new String[parameterTypes.length];
  parameterNames[0]=ENV.getName().substring(1);
  for (int i=1; i < parameterNames.length; i++) {
    parameterNames[i]="p" + i;
  }
  Function function=module.newFunction(Linkage._private,name,functionRef.getType(),parameterNames);
  Variable targetI8Ptr=function.newVariable(I8_PTR);
  if (trampoline instanceof org.nullvm.compiler.trampoline.Invoke) {
    org.nullvm.compiler.trampoline.Invoke invoke=(org.nullvm.compiler.trampoline.Invoke)trampoline;
    FunctionRef resolveFunc=null;
    List<Value> args=new ArrayList<Value>();
    args.add(ENV);
    if (invoke instanceof Invokespecial) {
      resolveFunc=NVM_BC_RESOLVE_INVOKESPECIAL;
      args.add(getString(((Invokespecial)invoke).getRuntimeClass()));
    }
 else     if (invoke instanceof Invokestatic) {
      resolveFunc=NVM_BC_RESOLVE_INVOKESTATIC;
    }
 else     if (invoke instanceof Invokevirtual) {
      resolveFunc=NVM_BC_RESOLVE_INVOKEVIRTUAL;
      args.add(getString(((Invokevirtual)invoke).getRuntimeClass()));
    }
 else     if (invoke instanceof Invokeinterface) {
      resolveFunc=NVM_BC_RESOLVE_INVOKEINTERFACE;
    }
    args.add(getString(invoke.getTargetClass()));
    args.add(getString(invoke.getMethodName()));
    args.add(getString(invoke.getMethodDesc()));
    args.add(getCaller(function));
    args.add(new ConstantBitcast(ptr,I8_PTR));
    function.add(new Call(targetI8Ptr,resolveFunc,args.toArray(new Value[args.size()])));
  }
 else   if (trampoline instanceof NativeCall) {
    NativeCall nativeCall=(NativeCall)trampoline;
    function.add(new Call(targetI8Ptr,NVM_BC_RESOLVE_NATIVE,ENV,getString(nativeCall.getTargetClass()),getString(nativeCall.getMethodName()),getString(nativeCall.getMethodDesc()),getString(mangleNativeMethod(nativeCall.getTargetClass(),nativeCall.getMethodName())),getString(mangleNativeMethod(nativeCall.getTargetClass(),nativeCall.getMethodName(),nativeCall.getMethodDesc())),getCaller(function),new ConstantBitcast(ptr,I8_PTR)));
  }
 else   if (trampoline instanceof FieldAccessor) {
    FieldAccessor accessor=(FieldAccessor)trampoline;
    FunctionRef resolveFunc=null;
    List<Value> args=new ArrayList<Value>();
    args.add(ENV);
    if (accessor instanceof GetStatic) {
      resolveFunc=NVM_BC_RESOLVE_GETSTATIC;
    }
 else     if (accessor instanceof PutStatic) {
      resolveFunc=NVM_BC_RESOLVE_PUTSTATIC;
    }
 else     if (accessor instanceof GetField) {
      resolveFunc=NVM_BC_RESOLVE_GETFIELD;
      args.add(getString(((GetField)accessor).getRuntimeClass()));
    }
 else     if (accessor instanceof PutField) {
      resolveFunc=NVM_BC_RESOLVE_PUTFIELD;
      args.add(getString(((PutField)accessor).getRuntimeClass()));
    }
    args.add(getString(accessor.getTargetClass()));
    args.add(getString(accessor.getFieldName()));
    args.add(getString(accessor.getFieldDesc()));
    args.add(getCaller(function));
    args.add(new ConstantBitcast(ptr,I8_PTR));
    function.add(new Call(targetI8Ptr,resolveFunc,args.toArray(new Value[args.size()])));
  }
  Variable targetFuncPtr=function.newVariable(functionRef.getType());
  function.add(new Bitcast(targetFuncPtr,targetI8Ptr.ref(),functionRef.getType()));
  Value[] args=new Value[parameterTypes.length];
  for (int i=0; i < parameterTypes.length; i++) {
    args[i]=new VariableRef(parameterNames[i],parameterTypes[i]);
  }
  if (functionRef.getType().getReturnType() != VOID) {
    Variable result=function.newVariable(functionRef.getType().getReturnType());
    function.add(new Call(result,targetFuncPtr.ref(),args));
    function.add(new Ret(result.ref()));
  }
 else {
    function.add(new Call(targetFuncPtr.ref(),args));
    function.add(new Ret());
  }
  module.addGlobal(new Global(name + "_ptr",Linkage._private,functionRef));
}
