{
  Chain units=body.getUnits();
  List<List> webs=new ArrayList<List>();
  if (Options.v().verbose())   G.v().out.println("[" + body.getMethod().getName() + "] Splitting locals...");
  Map boxToSet=new HashMap(units.size() * 2 + 1,0.7f);
  if (Options.v().time())   Timers.v().splitPhase1Timer.start();
{
    ExceptionalUnitGraph graph=new ExceptionalUnitGraph(body);
    LocalDefs localDefs;
    localDefs=new SmartLocalDefs(graph,new SimpleLiveLocals(graph));
    LocalUses localUses=new SimpleLocalUses(graph,localDefs);
    if (Options.v().time())     Timers.v().splitPhase1Timer.end();
    if (Options.v().time())     Timers.v().splitPhase2Timer.start();
    Set<ValueBox> markedBoxes=new HashSet<ValueBox>();
    Map<ValueBox,Unit> boxToUnit=new HashMap<ValueBox,Unit>(units.size() * 2 + 1,0.7f);
    Iterator codeIt=units.iterator();
    while (codeIt.hasNext()) {
      Unit s=(Unit)codeIt.next();
      if (s.getDefBoxes().size() > 1)       throw new RuntimeException("stmt with more than 1 defbox!");
      if (s.getDefBoxes().size() < 1)       continue;
      ValueBox loBox=(ValueBox)s.getDefBoxes().get(0);
      Value lo=loBox.getValue();
      if (lo instanceof Local && !markedBoxes.contains(loBox)) {
        LinkedList<Unit> defsToVisit=new LinkedList<Unit>();
        LinkedList<ValueBox> boxesToVisit=new LinkedList<ValueBox>();
        List web=new ArrayList();
        webs.add(web);
        defsToVisit.add(s);
        markedBoxes.add(loBox);
        boxToUnit.put(loBox,s);
        while (!boxesToVisit.isEmpty() || !defsToVisit.isEmpty()) {
          if (!defsToVisit.isEmpty()) {
            Unit d=defsToVisit.removeFirst();
            web.add(d.getDefBoxes().get(0));
{
              List uses=localUses.getUsesOf(d);
              Iterator useIt=uses.iterator();
              while (useIt.hasNext()) {
                UnitValueBoxPair use=(UnitValueBoxPair)useIt.next();
                if (!markedBoxes.contains(use.valueBox)) {
                  markedBoxes.add(use.valueBox);
                  boxesToVisit.addLast(use.valueBox);
                  boxToUnit.put(use.valueBox,use.unit);
                }
              }
            }
          }
 else {
            ValueBox box=boxesToVisit.removeFirst();
            web.add(box);
{
              List<Unit> defs=localDefs.getDefsOfAt((Local)box.getValue(),boxToUnit.get(box));
              Iterator<Unit> defIt=defs.iterator();
              while (defIt.hasNext()) {
                Unit u=defIt.next();
                Iterator defBoxesIter=u.getDefBoxes().iterator();
                ValueBox b;
                for (; defBoxesIter.hasNext(); ) {
                  b=(ValueBox)defBoxesIter.next();
                  if (!markedBoxes.contains(b)) {
                    markedBoxes.add(b);
                    defsToVisit.addLast(u);
                    boxToUnit.put(b,u);
                  }
                }
              }
            }
          }
        }
      }
    }
    webs=mergeWebs(body,webs,boxToUnit,localUses);
  }
{
    Map<Local,Integer> localToUseCount=new HashMap<Local,Integer>(body.getLocalCount() * 2 + 1,0.7f);
    Iterator<List> webIt=webs.iterator();
    while (webIt.hasNext()) {
      List web=webIt.next();
      ValueBox rep=(ValueBox)web.get(0);
      Local desiredLocal=(Local)rep.getValue();
      if (!localToUseCount.containsKey(desiredLocal)) {
        localToUseCount.put(desiredLocal,new Integer(1));
      }
 else {
        int useCount=localToUseCount.get(desiredLocal).intValue() + 1;
        localToUseCount.put(desiredLocal,new Integer(useCount));
        Local local=(Local)desiredLocal.clone();
        local.setName(desiredLocal.getName() + "#" + useCount);
        body.getLocals().add(local);
{
          Iterator j=web.iterator();
          while (j.hasNext()) {
            ValueBox box=(ValueBox)j.next();
            box.setValue(local);
          }
        }
      }
    }
  }
  if (Options.v().time())   Timers.v().splitPhase2Timer.end();
}
