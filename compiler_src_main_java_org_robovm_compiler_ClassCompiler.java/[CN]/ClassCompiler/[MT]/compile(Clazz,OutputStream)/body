{
  methodCompiler.reset(clazz);
  bridgeMethodCompiler.reset(clazz);
  callbackMethodCompiler.reset(clazz);
  nativeMethodCompiler.reset(clazz);
  structMemberMethodCompiler.reset(clazz);
  globalValueMethodCompiler.reset(clazz);
  ClazzInfo ci=clazz.resetClazzInfo();
  mb=new ModuleBuilder();
  for (  CompilerPlugin compilerPlugin : config.getCompilerPlugins()) {
    compilerPlugin.beforeClass(config,clazz,mb);
  }
  sootClass=clazz.getSootClass();
  trampolines=new HashSet<Trampoline>();
  catches=new HashSet<String>();
  classFields=getClassFields(config.getOs(),config.getArch(),sootClass);
  instanceFields=getInstanceFields(config.getOs(),config.getArch(),sootClass);
  classType=getClassType(config.getOs(),config.getArch(),sootClass);
  instanceType=getInstanceType(config.getOs(),config.getArch(),sootClass);
  attributesEncoder.encode(mb,sootClass);
  if (!sootClass.declaresMethodByName("<clinit>") && hasConstantValueTags(classFields)) {
    SootMethod clinit=new SootMethod("<clinit>",Collections.EMPTY_LIST,VoidType.v(),Modifier.STATIC);
    JimpleBody body=Jimple.v().newBody(clinit);
    clinit.setActiveBody(body);
    body.getUnits().add(new JReturnVoidStmt());
    this.sootClass.addMethod(clinit);
  }
  if (isStruct(sootClass)) {
    SootMethod _sizeOf=new SootMethod("_sizeOf",Collections.EMPTY_LIST,IntType.v(),Modifier.PROTECTED);
    sootClass.addMethod(_sizeOf);
    SootMethod sizeOf=new SootMethod("sizeOf",Collections.EMPTY_LIST,IntType.v(),Modifier.PUBLIC | Modifier.STATIC);
    sootClass.addMethod(sizeOf);
  }
  mb.addInclude(getClass().getClassLoader().getResource(String.format("header-%s-%s.ll",config.getOs().getFamily(),config.getArch())));
  mb.addInclude(getClass().getClassLoader().getResource("header.ll"));
  mb.addFunction(createLdcClass());
  mb.addFunction(createLdcClassWrapper());
  Function allocator=createAllocator();
  mb.addFunction(allocator);
  mb.addFunction(createClassInitWrapperFunction(allocator.ref()));
  for (  SootField f : sootClass.getFields()) {
    Function getter=createFieldGetter(f,classFields,classType,instanceFields,instanceType);
    Function setter=createFieldSetter(f,classFields,classType,instanceFields,instanceType);
    mb.addFunction(getter);
    mb.addFunction(setter);
    if (f.isStatic() && !f.isPrivate()) {
      mb.addFunction(createClassInitWrapperFunction(getter.ref()));
      if (!f.isFinal()) {
        mb.addFunction(createClassInitWrapperFunction(setter.ref()));
      }
    }
  }
  for (  SootMethod method : sootClass.getMethods()) {
    for (    CompilerPlugin compilerPlugin : config.getCompilerPlugins()) {
      compilerPlugin.beforeMethod(config,clazz,method,mb);
    }
    String name=method.getName();
    Function function=null;
    if (hasBridgeAnnotation(method)) {
      function=bridgeMethod(method);
    }
 else     if (hasGlobalValueAnnotation(method)) {
      function=globalValueMethod(method);
    }
 else     if (isStruct(sootClass) && ("_sizeOf".equals(name) || "sizeOf".equals(name) || hasStructMemberAnnotation(method))) {
      function=structMember(method);
    }
 else     if (method.isNative()) {
      function=nativeMethod(method);
    }
 else     if (!method.isAbstract()) {
      function=method(method);
    }
    if (hasCallbackAnnotation(method)) {
      callbackMethod(method);
    }
    if (!name.equals("<clinit>") && !name.equals("<init>") && !method.isPrivate()&& !method.isStatic()&& !Modifier.isFinal(method.getModifiers())&& !Modifier.isFinal(sootClass.getModifiers())) {
      createLookupFunction(method);
    }
    if (method.isStatic()) {
      String fnName=mangleMethod(method);
      if (method.isSynchronized()) {
        fnName+="_synchronized";
      }
      FunctionRef fn=new FunctionRef(fnName,getFunctionType(method));
      mb.addFunction(createClassInitWrapperFunction(fn));
    }
    for (    CompilerPlugin compilerPlugin : config.getCompilerPlugins()) {
      if (function != null) {
        compilerPlugin.afterMethod(config,clazz,method,mb,function);
      }
    }
  }
  Set<String> trampolineDependencies=new HashSet<String>();
  for (  Trampoline trampoline : trampolines) {
    trampolineResolver.compile(mb,trampoline);
    trampolineDependencies.addAll(trampolineResolver.getDependencies());
  }
  Global classInfoStruct=null;
  try {
    if (!sootClass.isInterface()) {
      config.getVTableCache().get(sootClass);
    }
    classInfoStruct=new Global(mangleClass(sootClass) + "_info_struct",Linkage.weak,createClassInfoStruct());
  }
 catch (  IllegalArgumentException e) {
    classInfoStruct=new Global(mangleClass(sootClass) + "_info_struct",I8_PTR,true);
  }
  mb.addGlobal(classInfoStruct);
  Function infoFn=FunctionBuilder.infoStruct(sootClass);
  infoFn.add(new Ret(new ConstantBitcast(classInfoStruct.ref(),I8_PTR_PTR)));
  mb.addFunction(infoFn);
  for (  CompilerPlugin compilerPlugin : config.getCompilerPlugins()) {
    compilerPlugin.afterClass(config,clazz,mb);
  }
  out.write(mb.build().toString().getBytes("UTF-8"));
  ci.setCatchNames(catches);
  ci.setTrampolines(trampolines);
  ci.addDependency("java/lang/Object");
  if (sootClass.hasSuperclass() && !sootClass.isInterface()) {
    ci.addDependency(getInternalName(sootClass.getSuperclass()));
  }
  for (  SootClass iface : sootClass.getInterfaces()) {
    ci.addDependency(getInternalName(iface));
  }
  for (  SootField f : sootClass.getFields()) {
    addDependencyIfNeeded(clazz,f.getType());
  }
  for (  SootMethod m : sootClass.getMethods()) {
    addDependencyIfNeeded(clazz,m.getReturnType());
    @SuppressWarnings("unchecked") List<soot.Type> paramTypes=(List<soot.Type>)m.getParameterTypes();
    for (    soot.Type type : paramTypes) {
      addDependencyIfNeeded(clazz,type);
    }
  }
  ci.addDependencies(attributesEncoder.getDependencies());
  ci.addDependencies(trampolineDependencies);
  ci.addDependencies(catches);
  for (  Trampoline t : trampolines) {
    if (!(t instanceof LdcString)) {
      String desc=t.getTarget();
      if (desc.charAt(0) == 'L' || desc.charAt(0) == '[') {
        addDependencyIfNeeded(clazz,desc);
      }
 else {
        ci.addDependency(t.getTarget());
      }
    }
    if (t instanceof FieldAccessor) {
      addDependencyIfNeeded(clazz,((FieldAccessor)t).getFieldDesc());
    }
 else     if (t instanceof Invoke) {
      String methodDesc=((Invoke)t).getMethodDesc();
      addDependencyIfNeeded(clazz,getReturnTypeDescriptor(methodDesc));
      for (      String desc : getParameterDescriptors(methodDesc)) {
        addDependencyIfNeeded(clazz,desc);
      }
    }
  }
  clazz.saveClazzInfo();
}
