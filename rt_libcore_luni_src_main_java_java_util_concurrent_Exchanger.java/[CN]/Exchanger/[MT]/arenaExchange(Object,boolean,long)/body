{
  Node[] a=arena;
  Node p=participant.get();
  for (int i=p.index; ; ) {
    int b, m, c;
    long j;
    Node q=(Node)U.getObjectVolatile(a,j=(i << ASHIFT) + ABASE);
    if (q != null && U.compareAndSwapObject(a,j,q,null)) {
      Object v=q.item;
      q.match=item;
      Thread w=q.parked;
      if (w != null)       U.unpark(w);
      return v;
    }
 else     if (i <= (m=(b=bound) & MMASK) && q == null) {
      p.item=item;
      if (U.compareAndSwapObject(a,j,null,p)) {
        long end=(timed && m == 0) ? System.nanoTime() + ns : 0L;
        Thread t=Thread.currentThread();
        for (int h=p.hash, spins=SPINS; ; ) {
          Object v=p.match;
          if (v != null) {
            U.putOrderedObject(p,MATCH,null);
            p.item=null;
            p.hash=h;
            return v;
          }
 else           if (spins > 0) {
            h^=h << 1;
            h^=h >>> 3;
            h^=h << 10;
            if (h == 0)             h=SPINS | (int)t.getId();
 else             if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)             Thread.yield();
          }
 else           if (U.getObjectVolatile(a,j) != p)           spins=SPINS;
 else           if (!t.isInterrupted() && m == 0 && (!timed || (ns=end - System.nanoTime()) > 0L)) {
            U.putObject(t,BLOCKER,this);
            p.parked=t;
            if (U.getObjectVolatile(a,j) == p)             U.park(false,ns);
            p.parked=null;
            U.putObject(t,BLOCKER,null);
          }
 else           if (U.getObjectVolatile(a,j) == p && U.compareAndSwapObject(a,j,p,null)) {
            if (m != 0)             U.compareAndSwapInt(this,BOUND,b,b + SEQ - 1);
            p.item=null;
            p.hash=h;
            i=p.index>>>=1;
            if (Thread.interrupted())             return null;
            if (timed && m == 0 && ns <= 0L)             return TIMED_OUT;
            break;
          }
        }
      }
 else       p.item=null;
    }
 else {
      if (p.bound != b) {
        p.bound=b;
        p.collides=0;
        i=(i != m || m == 0) ? m : m - 1;
      }
 else       if ((c=p.collides) < m || m == FULL || !U.compareAndSwapInt(this,BOUND,b,b + SEQ + 1)) {
        p.collides=c + 1;
        i=(i == 0) ? m : i - 1;
      }
 else       i=m + 1;
      p.index=i;
    }
  }
}
