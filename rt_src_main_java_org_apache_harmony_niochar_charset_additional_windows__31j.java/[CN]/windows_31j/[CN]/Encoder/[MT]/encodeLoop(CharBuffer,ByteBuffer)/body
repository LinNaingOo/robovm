{
  int bbRemaining=bb.remaining();
  if (CharsetProviderImpl.hasLoadedNatives() && bb.isDirect() && cb.hasRemaining()&& cb.hasArray()) {
    int toProceed=(bbRemaining < cb.remaining()) ? bbRemaining : cb.remaining();
    int cbPos=cb.position();
    int bbPos=bb.position();
    int[] res={bbRemaining,cb.remaining(),0,0};
    nEncode(AddressUtil.getDirectBufferAddress(bb),bbPos,toProceed,cb.array(),cb.arrayOffset() + cbPos,res);
    bb.position(bbPos + bbRemaining - res[0]);
    cb.position(cbPos + cb.remaining() - res[1]);
    if (res[2] != 0) {
      if (res[3] == -1)       return CoderResult.malformedForLength(res[2]);
 else       return CoderResult.unmappableForLength(res[2]);
    }
 else {
      if (res[3] != 0)       return CoderResult.OVERFLOW;
    }
  }
 else {
    while (cb.hasRemaining()) {
      if (bbRemaining == 0)       return CoderResult.OVERFLOW;
      char c=cb.get();
      if (c > (char)0xFFE5) {
        cb.position(cb.position() - 1);
        return CoderResult.unmappableForLength(1);
      }
 else {
        if (c < 0x001A) {
          bb.put((byte)c);
        }
 else {
          int index=(int)c >> 8;
          index=encodeIndex[index];
          if (index < 0) {
            if (c >= 0xD800 && c <= 0xDFFF) {
              if (cb.hasRemaining()) {
                char c1=cb.get();
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                  cb.position(cb.position() - 2);
                  return CoderResult.unmappableForLength(2);
                }
 else {
                  cb.position(cb.position() - 1);
                }
              }
 else {
                cb.position(cb.position() - 1);
                return CoderResult.UNDERFLOW;
              }
              cb.position(cb.position() - 1);
              return CoderResult.malformedForLength(1);
            }
            cb.position(cb.position() - 1);
            return CoderResult.unmappableForLength(1);
          }
          int variable=(index >> 4);
          index<<=8;
          index+=(int)c & 0xFF;
          index=index - (variable << 12);
          char resultChar='\u0000';
switch (variable) {
case 0:
            resultChar=arrEncode0.charAt(index);
          break;
case 1:
        resultChar=arrEncode1.charAt(index);
      break;
case 2:
    resultChar=arrEncode2.charAt(index);
  break;
case 3:
resultChar=arrEncode3.charAt(index);
break;
case 4:
resultChar=arrEncode4.charAt(index);
break;
case 5:
resultChar=arrEncode5.charAt(index);
break;
case 6:
resultChar=arrEncode6.charAt(index);
break;
}
if (resultChar != '\u0000') {
byte b=(byte)(resultChar >> 8);
if (b != 0) {
bb.put(b);
bbRemaining--;
if (bbRemaining == 0) {
cb.position(cb.position() - 1);
return CoderResult.OVERFLOW;
}
}
bb.put((byte)(resultChar & 0xFF));
bbRemaining--;
}
 else {
cb.position(cb.position() - 1);
return CoderResult.unmappableForLength(1);
}
}
}
}
}
return CoderResult.UNDERFLOW;
}
