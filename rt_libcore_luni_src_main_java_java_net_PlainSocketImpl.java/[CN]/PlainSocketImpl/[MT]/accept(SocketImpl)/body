{
  if (usingSocks()) {
    ((PlainSocketImpl)newImpl).socksBind();
    ((PlainSocketImpl)newImpl).socksAccept();
    return;
  }
  try {
    int timeout=(Integer)getOption(SO_TIMEOUT);
    int flags=Libcore.os.fcntlVoid(fd,F_GETFL);
    if (timeout > 0 && (flags & O_NONBLOCK) == 0) {
      StructPollfd pfd=new StructPollfd();
      pfd.fd=fd;
      pfd.events=(short)(POLLIN | POLLERR);
      StructPollfd[] pfds=new StructPollfd[]{pfd};
      long start=System.currentTimeMillis();
      long deadline=start + timeout;
      while (true) {
        try {
          if (timeout <= 0 || Libcore.os.poll(pfds,timeout) == 0) {
            throw new SocketTimeoutException("accept() timed out");
          }
          break;
        }
 catch (        ErrnoException e) {
          if (e.errno == EINTR) {
            long now=System.currentTimeMillis();
            timeout=(int)(deadline - now);
          }
 else {
            throw e;
          }
        }
      }
    }
    InetSocketAddress peerAddress=new InetSocketAddress();
    FileDescriptor clientFd=Libcore.os.accept(fd,peerAddress);
    newImpl.fd.setInt$(clientFd.getInt$());
    newImpl.address=peerAddress.getAddress();
    newImpl.port=peerAddress.getPort();
  }
 catch (  ErrnoException errnoException) {
    if (errnoException.errno == EAGAIN) {
      throw new SocketTimeoutException(errnoException);
    }
    throw errnoException.rethrowAsSocketException();
  }
  newImpl.setOption(SocketOptions.SO_TIMEOUT,Integer.valueOf(0));
  newImpl.localport=IoBridge.getSocketLocalPort(newImpl.fd);
}
