{
  if (s instanceof DefinitionStmt) {
    DefinitionStmt ds=(DefinitionStmt)s;
    if (ds.getLeftOp() instanceof Local && ds.getRightOp() instanceof Constant) {
      if (!constants.contains(ds.getLeftOp())) {
        constants.add(ds.getLeftOp());
      }
 else {
        constants.remove(ds.getLeftOp());
      }
    }
  }
  if (s instanceof GotoStmt)   return;
  if (s instanceof InvokeStmt)   return;
  G.v().out.println("s : " + s + " use boxes: "+ s.getUseBoxes()+ " def boxes: "+ s.getDefBoxes());
  Iterator useBoxesIt=s.getUseBoxes().iterator();
  boolean result=true;
  uses:   while (useBoxesIt.hasNext()) {
    ValueBox vb=(ValueBox)useBoxesIt.next();
    Value v=vb.getValue();
    if (v instanceof NewExpr) {
      result=false;
      G.v().out.println("break uses: due to new expr");
      break uses;
    }
    if (v instanceof InvokeExpr) {
      result=false;
      G.v().out.println("break uses: due to invoke expr");
      break uses;
    }
    if (v instanceof Expr)     continue;
    G.v().out.println("test: " + v + " of kind: "+ v.getClass());
    Iterator loopStmtsIt=loopStmts.iterator();
    while (loopStmtsIt.hasNext()) {
      Stmt next=(Stmt)loopStmtsIt.next();
      if (nset.unitCanWriteTo(next,v)) {
        if (!isConstant(next)) {
          G.v().out.println("result = false unit can be written to by: " + next);
          result=false;
          break uses;
        }
      }
    }
  }
  Iterator defBoxesIt=s.getDefBoxes().iterator();
  defs:   while (defBoxesIt.hasNext()) {
    ValueBox vb=(ValueBox)defBoxesIt.next();
    Value v=vb.getValue();
    if (v instanceof NewExpr) {
      result=false;
      G.v().out.println("break defs due to new");
      break defs;
    }
    if (v instanceof InvokeExpr) {
      result=false;
      G.v().out.println("break defs due to invoke");
      break defs;
    }
    if (v instanceof Expr)     continue;
    G.v().out.println("test: " + v + " of kind: "+ v.getClass());
    Iterator loopStmtsIt=loopStmts.iterator();
    while (loopStmtsIt.hasNext()) {
      Stmt next=(Stmt)loopStmtsIt.next();
      if (next.equals(s))       continue;
      if (nset.unitCanWriteTo(next,v)) {
        if (!isConstant(next)) {
          G.v().out.println("result false: unit can be written to by: " + next);
          result=false;
          break defs;
        }
      }
    }
  }
  G.v().out.println("stmt: " + s + " result: "+ result);
  if (result) {
    s.addTag(new LoopInvariantTag("is loop invariant"));
    s.addTag(new ColorTag(ColorTag.RED,"Loop Invariant Analysis"));
  }
 else {
  }
}
