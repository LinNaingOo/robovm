{
synchronized (handshakeLock) {
    checkOpen();
    if (!handshakeStarted) {
      handshakeStarted=true;
    }
 else {
      return;
    }
  }
  final int seedLengthInBytes=NativeCrypto.RAND_SEED_LENGTH_IN_BYTES;
  final SecureRandom secureRandom=sslParameters.getSecureRandomMember();
  if (secureRandom == null) {
    NativeCrypto.RAND_load_file("/dev/urandom",seedLengthInBytes);
  }
 else {
    NativeCrypto.RAND_seed(secureRandom.generateSeed(seedLengthInBytes));
  }
  final boolean client=sslParameters.getUseClientMode();
  final long sslCtxNativePointer=(client) ? sslParameters.getClientSessionContext().sslCtxNativePointer : sslParameters.getServerSessionContext().sslCtxNativePointer;
  this.sslNativePointer=0;
  boolean exception=true;
  try {
    sslNativePointer=NativeCrypto.SSL_new(sslCtxNativePointer);
    guard.open("close");
    if (npnProtocols != null) {
      NativeCrypto.SSL_CTX_enable_npn(sslCtxNativePointer);
    }
    if (client && alpnProtocols != null) {
      NativeCrypto.SSL_CTX_set_alpn_protos(sslCtxNativePointer,alpnProtocols);
    }
    if (!client) {
      Set<String> keyTypes=new HashSet<String>();
      for (      String enabledCipherSuite : enabledCipherSuites) {
        if (enabledCipherSuite.equals(NativeCrypto.TLS_EMPTY_RENEGOTIATION_INFO_SCSV)) {
          continue;
        }
        String keyType=CipherSuite.getByName(enabledCipherSuite).getServerKeyType();
        if (keyType != null) {
          keyTypes.add(keyType);
        }
      }
      for (      String keyType : keyTypes) {
        try {
          setCertificate(sslParameters.getKeyManager().chooseServerAlias(keyType,null,this));
        }
 catch (        CertificateEncodingException e) {
          throw new IOException(e);
        }
      }
    }
    NativeCrypto.setEnabledProtocols(sslNativePointer,enabledProtocols);
    NativeCrypto.setEnabledCipherSuites(sslNativePointer,enabledCipherSuites);
    if (useSessionTickets) {
      NativeCrypto.SSL_clear_options(sslNativePointer,NativeCrypto.SSL_OP_NO_TICKET);
    }
    if (hostname != null) {
      NativeCrypto.SSL_set_tlsext_host_name(sslNativePointer,hostname);
    }
    boolean enableSessionCreation=sslParameters.getEnableSessionCreation();
    if (!enableSessionCreation) {
      NativeCrypto.SSL_set_session_creation_enabled(sslNativePointer,enableSessionCreation);
    }
    AbstractSessionContext sessionContext;
    OpenSSLSessionImpl sessionToReuse;
    if (client) {
      ClientSessionContext clientSessionContext=sslParameters.getClientSessionContext();
      sessionContext=clientSessionContext;
      sessionToReuse=getCachedClientSession(clientSessionContext);
      if (sessionToReuse != null) {
        NativeCrypto.SSL_set_session(sslNativePointer,sessionToReuse.sslSessionNativePointer);
      }
    }
 else {
      sessionContext=sslParameters.getServerSessionContext();
      sessionToReuse=null;
    }
    if (client) {
    }
 else {
      boolean certRequested;
      if (sslParameters.getNeedClientAuth()) {
        NativeCrypto.SSL_set_verify(sslNativePointer,NativeCrypto.SSL_VERIFY_PEER | NativeCrypto.SSL_VERIFY_FAIL_IF_NO_PEER_CERT);
        certRequested=true;
      }
 else       if (sslParameters.getWantClientAuth()) {
        NativeCrypto.SSL_set_verify(sslNativePointer,NativeCrypto.SSL_VERIFY_PEER);
        certRequested=true;
      }
 else {
        certRequested=false;
      }
      if (certRequested) {
        X509TrustManager trustManager=sslParameters.getTrustManager();
        X509Certificate[] issuers=trustManager.getAcceptedIssuers();
        if (issuers != null && issuers.length != 0) {
          byte[][] issuersBytes;
          try {
            issuersBytes=encodeIssuerX509Principals(issuers);
          }
 catch (          CertificateEncodingException e) {
            throw new IOException("Problem encoding principals",e);
          }
          NativeCrypto.SSL_set_client_CA_list(sslNativePointer,issuersBytes);
        }
      }
    }
    int savedReadTimeoutMilliseconds=getSoTimeout();
    int savedWriteTimeoutMilliseconds=getSoWriteTimeout();
    if (handshakeTimeoutMilliseconds >= 0) {
      setSoTimeout(handshakeTimeoutMilliseconds);
      setSoWriteTimeout(handshakeTimeoutMilliseconds);
    }
    if (channelIdEnabled) {
      if (client) {
        if (channelIdPrivateKey == null) {
          throw new SSLHandshakeException("Invalid TLS channel ID key specified");
        }
        NativeCrypto.SSL_set1_tls_channel_id(sslNativePointer,channelIdPrivateKey.getPkeyContext());
      }
 else {
        NativeCrypto.SSL_enable_tls_channel_id(sslNativePointer);
      }
    }
    long sslSessionNativePointer;
    try {
      sslSessionNativePointer=NativeCrypto.SSL_do_handshake(sslNativePointer,socket.getFileDescriptor$(),this,getSoTimeout(),client,npnProtocols,client ? null : alpnProtocols);
    }
 catch (    CertificateException e) {
      SSLHandshakeException wrapper=new SSLHandshakeException(e.getMessage());
      wrapper.initCause(e);
      throw wrapper;
    }
    byte[] sessionId=NativeCrypto.SSL_SESSION_session_id(sslSessionNativePointer);
    if (sessionToReuse != null && Arrays.equals(sessionToReuse.getId(),sessionId)) {
      this.sslSession=sessionToReuse;
      sslSession.lastAccessedTime=System.currentTimeMillis();
      NativeCrypto.SSL_SESSION_free(sslSessionNativePointer);
    }
 else {
      if (!enableSessionCreation) {
        throw new IllegalStateException("SSL Session may not be created");
      }
      X509Certificate[] localCertificates=createCertChain(NativeCrypto.SSL_get_certificate(sslNativePointer));
      X509Certificate[] peerCertificates=createCertChain(NativeCrypto.SSL_get_peer_cert_chain(sslNativePointer));
      this.sslSession=new OpenSSLSessionImpl(sslSessionNativePointer,localCertificates,peerCertificates,getPeerHostName(),getPeerPort(),sessionContext);
      if (handshakeCompleted) {
        sessionContext.putSession(sslSession);
      }
    }
    if (handshakeTimeoutMilliseconds >= 0) {
      setSoTimeout(savedReadTimeoutMilliseconds);
      setSoWriteTimeout(savedWriteTimeoutMilliseconds);
    }
    if (handshakeCompleted) {
      notifyHandshakeCompletedListeners();
    }
    exception=false;
  }
 catch (  SSLProtocolException e) {
    throw new SSLHandshakeException(e);
  }
 finally {
    if (exception) {
      close();
    }
  }
}
