{
  int outRemaining=out.remaining();
  int pos=in.position();
  int limit=in.limit();
  if (in.hasArray() && out.hasArray()) {
    final byte[] bArr=in.array();
    final char[] cArr=out.array();
    final int inIndexLimit=limit + in.arrayOffset();
    int inIndex=pos + in.arrayOffset();
    int outIndex=out.position() + out.arrayOffset();
    for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {
      int jchar=bArr[inIndex];
      if (jchar < 0) {
        jchar=jchar & 0x7F;
        int tail=remainingBytes[jchar];
        if (tail == -1) {
          in.position(inIndex - in.arrayOffset());
          out.position(outIndex - out.arrayOffset());
          return CoderResult.malformedForLength(1);
        }
        if (inIndexLimit - inIndex < 1 + tail) {
          break;
        }
        for (int i=0; i < tail; i++) {
          int nextByte=bArr[inIndex + i + 1] & 0xFF;
          if ((nextByte & 0xC0) != 0x80) {
            in.position(inIndex - in.arrayOffset());
            out.position(outIndex - out.arrayOffset());
            return CoderResult.malformedForLength(1 + i);
          }
          jchar=(jchar << 6) + nextByte;
        }
        jchar-=remainingNumbers[tail];
        if (jchar < lowerEncodingLimit[tail]) {
          in.position(inIndex - in.arrayOffset());
          out.position(outIndex - out.arrayOffset());
          return CoderResult.malformedForLength(1);
        }
        inIndex+=tail;
      }
      cArr[outIndex++]=(char)jchar;
      outRemaining--;
    }
    in.position(inIndex - in.arrayOffset());
    out.position(outIndex - out.arrayOffset());
    return (outRemaining == 0 && inIndex < inIndexLimit) ? CoderResult.OVERFLOW : CoderResult.UNDERFLOW;
  }
 else {
    try {
      while (pos < limit) {
        if (outRemaining == 0) {
          return CoderResult.OVERFLOW;
        }
        int jchar=in.get();
        if (jchar < 0) {
          jchar=jchar & 0x7F;
          int tail=remainingBytes[jchar];
          if (tail == -1) {
            return CoderResult.malformedForLength(1);
          }
          if (limit - pos < 1 + tail) {
            return CoderResult.UNDERFLOW;
          }
          int nextByte;
          for (int i=0; i < tail; i++) {
            nextByte=in.get() & 0xFF;
            if ((nextByte & 0xC0) != 0x80) {
              return CoderResult.malformedForLength(1 + i);
            }
            jchar=(jchar << 6) + nextByte;
          }
          jchar-=remainingNumbers[tail];
          if (jchar < lowerEncodingLimit[tail]) {
            return CoderResult.malformedForLength(1);
          }
          pos+=tail;
        }
        pos++;
        out.put((char)jchar);
        outRemaining--;
      }
      return CoderResult.UNDERFLOW;
    }
  finally {
      in.position(pos);
    }
  }
}
