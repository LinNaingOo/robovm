{
  List filteredHeads=new LinkedList();
  while (heads.hasNext()) {
    SootMethod m=(SootMethod)heads.next();
    if (m.isConcrete() && filter.want(m))     filteredHeads.add(m);
  }
  this.nodes=new HashSet(filteredHeads);
  MultiMap s=new HashMultiMap();
  MultiMap p=new HashMultiMap();
  Set remain=new HashSet(filteredHeads);
  int nb=0;
  if (verbose)   G.v().out.println("[AM] dumping method dependencies");
  while (!remain.isEmpty()) {
    Set newRemain=new HashSet();
    Iterator it=remain.iterator();
    while (it.hasNext()) {
      SootMethod m=(SootMethod)it.next();
      Iterator itt=cg.edgesOutOf(m);
      if (verbose)       G.v().out.println(" |- " + m.toString() + " calls");
      while (itt.hasNext()) {
        Edge edge=(Edge)itt.next();
        SootMethod mm=edge.tgt();
        boolean keep=mm.isConcrete() && filter.want(mm);
        if (verbose)         G.v().out.println(" |  |- " + mm.toString() + (keep ? "" : " (filtered out)"));
        if (keep) {
          if (this.nodes.add(mm))           newRemain.add(mm);
          s.put(m,mm);
          p.put(mm,m);
        }
      }
      nb++;
    }
    remain=newRemain;
  }
  G.v().out.println("[AM] number of methods to be analysed: " + nb);
  this.succ=new HashMap();
  this.pred=new HashMap();
  this.tails=new LinkedList();
  this.heads=new LinkedList();
  Iterator it=this.nodes.iterator();
  while (it.hasNext()) {
    Object x=it.next();
    Set ss=s.get(x);
    Set pp=p.get(x);
    this.succ.put(x,new LinkedList(ss));
    this.pred.put(x,new LinkedList(pp));
    if (ss.isEmpty())     this.tails.add(x);
    if (pp.isEmpty())     this.heads.add(x);
  }
  this.size=this.nodes.size();
}
