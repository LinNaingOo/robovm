{
switch (implKind) {
case SMethodHandleInfo.REF_invokeInterface:
case SMethodHandleInfo.REF_invokeVirtual:
case SMethodHandleInfo.REF_invokeStatic:
case SMethodHandleInfo.REF_newInvokeSpecial:
case SMethodHandleInfo.REF_invokeSpecial:
    break;
default :
  throw new LambdaConversionException(String.format("Unsupported MethodHandle kind: %s",implInfo));
}
final int implArity=implMethodType.parameterCount();
final int receiverArity=implIsInstanceMethod ? 1 : 0;
final int capturedArity=invokedType.parameterCount();
final int samArity=samMethodType.parameterCount();
final int instantiatedArity=instantiatedMethodType.parameterCount();
if (implArity + receiverArity != capturedArity + samArity) {
throw new LambdaConversionException(String.format("Incorrect number of parameters for %s method %s; %d captured parameters, %d functional interface method parameters, %d implementation parameters",implIsInstanceMethod ? "instance" : "static",implInfo,capturedArity,samArity,implArity));
}
if (instantiatedArity != samArity) {
throw new LambdaConversionException(String.format("Incorrect number of parameters for %s method %s; %d instantiated parameters, %d functional interface method parameters",implIsInstanceMethod ? "instance" : "static",implInfo,instantiatedArity,samArity));
}
for (SMethodType bridgeMT : additionalBridges) {
if (bridgeMT.parameterCount() != samArity) {
  throw new LambdaConversionException(String.format("Incorrect number of parameters for bridge signature %s; incompatible with %s",bridgeMT,samMethodType));
}
}
final int capturedStart;
final int samStart;
if (implIsInstanceMethod) {
final SClass<?> receiverClass;
if (capturedArity == 0) {
  capturedStart=0;
  samStart=1;
  receiverClass=instantiatedMethodType.parameterType(0);
}
 else {
  capturedStart=1;
  samStart=0;
  receiverClass=invokedType.parameterType(0);
}
if (!implDefiningClass.isAssignableFrom(receiverClass)) {
  throw new LambdaConversionException(String.format("Invalid receiver type %s; not a subtype of implementation type %s",receiverClass,implDefiningClass));
}
SClass<?> implReceiverClass=implMethod.type().parameterType(0);
if (implReceiverClass != implDefiningClass && !implReceiverClass.isAssignableFrom(receiverClass)) {
  throw new LambdaConversionException(String.format("Invalid receiver type %s; not a subtype of implementation receiver type %s",receiverClass,implReceiverClass));
}
}
 else {
capturedStart=0;
samStart=0;
}
final int implFromCaptured=capturedArity - capturedStart;
for (int i=0; i < implFromCaptured; i++) {
SClass<?> implParamType=implMethodType.parameterType(i);
SClass<?> capturedParamType=invokedType.parameterType(i + capturedStart);
if (!capturedParamType.equals(implParamType)) {
  throw new LambdaConversionException(String.format("Type mismatch in captured lambda parameter %d: expecting %s, found %s",i,capturedParamType,implParamType));
}
}
final int samOffset=samStart - implFromCaptured;
for (int i=implFromCaptured; i < implArity; i++) {
SClass<?> implParamType=implMethodType.parameterType(i);
SClass<?> instantiatedParamType=instantiatedMethodType.parameterType(i + samOffset);
if (!isAdaptableTo(instantiatedParamType,implParamType,true)) {
  throw new LambdaConversionException(String.format("Type mismatch for lambda argument %d: %s is not convertible to %s",i,instantiatedParamType,implParamType));
}
}
SClass<?> expectedType=instantiatedMethodType.returnType();
SClass<?> actualReturnType=(implKind == SMethodHandleInfo.REF_newInvokeSpecial) ? implDefiningClass : implMethodType.returnType();
SClass<?> samReturnType=samMethodType.returnType();
if (!isAdaptableToAsReturn(actualReturnType,expectedType)) {
throw new LambdaConversionException(String.format("Type mismatch for lambda return: %s is not convertible to %s",actualReturnType,expectedType));
}
if (!isAdaptableToAsReturnStrict(expectedType,samReturnType)) {
throw new LambdaConversionException(String.format("Type mismatch for lambda expected return: %s is not convertible to %s",expectedType,samReturnType));
}
for (SMethodType bridgeMT : additionalBridges) {
if (!isAdaptableToAsReturnStrict(expectedType,bridgeMT.returnType())) {
  throw new LambdaConversionException(String.format("Type mismatch for lambda expected return: %s is not convertible to %s",expectedType,bridgeMT.returnType()));
}
}
}
