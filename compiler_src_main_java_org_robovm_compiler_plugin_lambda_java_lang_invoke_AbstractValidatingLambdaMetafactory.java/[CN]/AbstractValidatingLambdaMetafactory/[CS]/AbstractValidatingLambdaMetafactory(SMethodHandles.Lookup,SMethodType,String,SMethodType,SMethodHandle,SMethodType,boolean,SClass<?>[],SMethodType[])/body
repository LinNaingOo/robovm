{
  this.targetClass=caller.lookupClass();
  this.invokedType=invokedType;
  this.samBase=invokedType.returnType();
  this.samMethodName=samMethodName;
  this.samMethodType=samMethodType;
  this.implMethod=implMethod;
  this.implInfo=caller.revealDirect(implMethod);
  this.implKind=implInfo.getReferenceKind();
  this.implIsInstanceMethod=implKind == SMethodHandleInfo.REF_invokeVirtual || implKind == SMethodHandleInfo.REF_invokeSpecial || implKind == SMethodHandleInfo.REF_invokeInterface;
  this.implDefiningClass=implInfo.getDeclaringClass();
  this.implMethodType=implInfo.getMethodType();
  this.instantiatedMethodType=instantiatedMethodType;
  this.isSerializable=isSerializable;
  this.markerInterfaces=markerInterfaces;
  this.additionalBridges=additionalBridges;
  if (!samBase.isInterface()) {
    throw new LambdaConversionException(String.format("Functional interface %s is not an interface",samBase.getName()));
  }
  for (  SClass<?> c : markerInterfaces) {
    if (!c.isInterface()) {
      throw new LambdaConversionException(String.format("Marker interface %s is not an interface",c.getName()));
    }
  }
}
