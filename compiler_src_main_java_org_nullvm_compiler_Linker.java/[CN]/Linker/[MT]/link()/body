{
  strings=new HashMap<String,Global>();
  functionDeclarations=new HashMap<String,FunctionDeclaration>();
  aliases=new TreeMap<String,String>();
  Set<Clazz> required=new TreeSet<Clazz>(findRequiredClasses());
  config.getLogger().info("Linking %d classes",required.size());
  Module module=new Module();
  module.addInclude(getClass().getClassLoader().getResource("header.ll"));
  HashTableGenerator<String,Constant> bcpHashGen=new HashTableGenerator<String,Constant>(new ModifiedUtf8HashFunction());
  HashTableGenerator<String,Constant> cpHashGen=new HashTableGenerator<String,Constant>(new ModifiedUtf8HashFunction());
  Set<Trampoline> trampolines=new HashSet<Trampoline>();
  for (  Clazz clazz : required) {
    Global info=new Global(mangleClass(clazz.getInternalName()) + "_info",Linkage.external,I8_PTR,false);
    module.addGlobal(info);
    if (clazz.isInBootClasspath()) {
      bcpHashGen.put(clazz.getInternalName(),info.ref());
    }
 else {
      cpHashGen.put(clazz.getInternalName(),info.ref());
    }
    trampolines.addAll(clazz.getClazzInfo().getTrampolines());
    if (!clazz.getClazzInfo().isInterface()) {
      String superclassName=clazz.getClazzInfo().getSuperclass();
      if (superclassName != null && !"java/lang/Object".equals(superclassName)) {
        module.addGlobal(new Global(mangleClass(clazz.getInternalName()) + "_offset",alignedOffset(clazz),true));
      }
    }
  }
  module.addGlobal(new Global("_nvmBcBootClassesHash",new ConstantGetelementptr(module.newGlobal(bcpHashGen.generate(),true).ref(),0,0)));
  module.addGlobal(new Global("_nvmBcClassesHash",new ConstantGetelementptr(module.newGlobal(cpHashGen.generate(),true).ref(),0,0)));
  ArrayConstantBuilder bootClasspathValues=new ArrayConstantBuilder(I8_PTR);
  ArrayConstantBuilder classpathValues=new ArrayConstantBuilder(I8_PTR);
  for (  Path path : config.getClazzes().getPaths()) {
    String entryName=null;
    if (config.isSkipInstall() && config.getTarget().canLaunchInPlace()) {
      entryName=path.getFile().getAbsolutePath();
    }
 else {
      entryName=config.getTarget().getInstallRelativeArchivePath(path);
    }
    if (path.isInBootClasspath()) {
      bootClasspathValues.add(getString(entryName));
    }
 else {
      classpathValues.add(getString(entryName));
    }
  }
  bootClasspathValues.add(new NullConstant(Type.I8_PTR));
  classpathValues.add(new NullConstant(Type.I8_PTR));
  module.newGlobal(bootClasspathValues.build());
  module.addGlobal(new Global("_nvmBcBootclasspath",new ConstantGetelementptr(module.newGlobal(bootClasspathValues.build()).ref(),0,0)));
  module.addGlobal(new Global("_nvmBcClasspath",new ConstantGetelementptr(module.newGlobal(classpathValues.build()).ref(),0,0)));
  if (config.getMainClass() != null) {
    module.addGlobal(new Global("_nvmBcMainClass",getString(config.getMainClass())));
  }
  for (  Trampoline t : trampolines) {
    createTrampoline(module,t);
  }
  for (  Global g : strings.values()) {
    module.addGlobal(g);
  }
  for (  FunctionDeclaration fd : functionDeclarations.values()) {
    module.addFunctionDeclaration(fd);
  }
  File linkerLl=new File(config.getTmpDir(),"linker.ll");
  FileUtils.writeStringToFile(linkerLl,module.toString(),"UTF-8");
  File linkerBc=new File(config.getTmpDir(),"linker.bc");
  CompilerUtil.opt(config,linkerLl,linkerBc,"-mem2reg","-always-inline");
  File linkerS=new File(config.getTmpDir(),"linker.s");
  CompilerUtil.llc(config,linkerBc,linkerS);
  List<File> objectFiles=new ArrayList<File>();
  objectFiles.add(linkerS);
  Set<Package> packages=new TreeSet<Package>();
  for (  Clazz clazz : required) {
    packages.add(clazz.getPackage());
    objectFiles.add(config.getOFile(clazz));
  }
  List<File> libFiles=new ArrayList<File>();
  config.getTarget().build(objectFiles,libFiles,aliases);
}
