{
  if (ret == null) {
    return astore.next;
  }
  Instruction last=this.lastInstruction;
  Instruction headbefore=last;
  int curlabel=this.lastInstruction.label;
  HashMap<Instruction,Instruction> insnmap=new HashMap<Instruction,Instruction>();
  Instruction insn=astore.next;
  while (insn != ret && insn != null) {
    try {
      Instruction newone=(Instruction)insn.clone();
      newone.label=++curlabel;
      newone.prev=last;
      last.next=newone;
      last=newone;
      insnmap.put(insn,newone);
    }
 catch (    CloneNotSupportedException e) {
      G.v().out.println("Error !");
    }
    insn=insn.next;
  }
  Instruction_Goto togo=new Instruction_Goto();
  togo.target=target;
  target.labelled=true;
  togo.label=++curlabel;
  last.next=togo;
  togo.prev=last;
  last=togo;
  this.lastInstruction=last;
  insnmap.put(astore,headbefore.next);
  insnmap.put(ret,togo);
  insn=headbefore.next;
  while (insn != last) {
    if (insn instanceof Instruction_branch) {
      Instruction oldtgt=((Instruction_branch)insn).target;
      Instruction newtgt=insnmap.get(oldtgt);
      if (newtgt != null) {
        ((Instruction_branch)insn).target=newtgt;
        newtgt.labelled=true;
      }
    }
 else     if (insn instanceof Instruction_Lookupswitch) {
      Instruction_Lookupswitch switchinsn=(Instruction_Lookupswitch)insn;
      Instruction newdefault=insnmap.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i < switchinsn.match_insts.length; i++) {
        Instruction newtgt=insnmap.get(switchinsn.match_insts[i]);
        if (newtgt != null) {
          switchinsn.match_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
 else     if (insn instanceof Instruction_Tableswitch) {
      Instruction_Tableswitch switchinsn=(Instruction_Tableswitch)insn;
      Instruction newdefault=insnmap.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i < switchinsn.jump_insts.length; i++) {
        Instruction newtgt=insnmap.get(switchinsn.jump_insts[i]);
        if (newtgt != null) {
          switchinsn.jump_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
    insn=insn.next;
  }
{
    Code_attribute ca=method.locate_code_attribute();
    LinkedList<exception_table_entry> newentries=new LinkedList<exception_table_entry>();
    int orig_start_of_subr=astore.next.originalIndex;
    int orig_end_of_subr=ret.originalIndex;
    for (int i=0; i < ca.exception_table_length; i++) {
      exception_table_entry etentry=ca.exception_table[i];
      int orig_start_of_trap=etentry.start_pc;
      int orig_end_of_trap=etentry.end_pc;
      if (orig_start_of_trap < orig_end_of_subr && orig_end_of_trap > orig_start_of_subr) {
        exception_table_entry newone=new exception_table_entry();
        if (orig_start_of_trap <= orig_start_of_subr) {
          newone.start_inst=headbefore.next;
        }
 else {
          Instruction ins=insnmap.get(etentry.start_inst);
          if (ins != null)           newone.start_inst=insnmap.get(etentry.start_inst);
 else           newone.start_inst=etentry.start_inst;
        }
        if (orig_end_of_trap > orig_end_of_subr) {
          newone.end_inst=null;
        }
 else {
          newone.end_inst=insnmap.get(etentry.end_inst);
        }
        newone.handler_inst=insnmap.get(etentry.handler_inst);
        if (newone.handler_inst == null)         newone.handler_inst=etentry.handler_inst;
        newentries.add(newone);
      }
      if (etentry.end_inst == null) {
        etentry.end_inst=headbefore.next;
      }
    }
    if (newentries.size() > 0) {
      ca.exception_table_length+=newentries.size();
      exception_table_entry[] newtable=new exception_table_entry[ca.exception_table_length];
      System.arraycopy(ca.exception_table,0,newtable,0,ca.exception_table.length);
      for (int i=0, j=ca.exception_table.length; i < newentries.size(); i++, j++) {
        newtable[j]=newentries.get(i);
      }
      ca.exception_table=newtable;
    }
  }
  return headbefore.next;
}
