{
  if (ret == null) {
    return astore.next;
  }
  Instruction last=this.lastInstruction;
  Instruction headbefore=last;
  int curlabel=this.lastInstruction.label;
  HashMap<Instruction,Instruction> insnmap=new HashMap<Instruction,Instruction>();
  Instruction insn=astore.next;
  while (insn != ret && insn != null) {
    try {
      Instruction newone=(Instruction)insn.clone();
      newone.label=++curlabel;
      newone.prev=last;
      last.next=newone;
      last=newone;
      insnmap.put(insn,newone);
    }
 catch (    CloneNotSupportedException e) {
      G.v().out.println("Error !");
    }
    insn=insn.next;
  }
  Instruction_Goto togo=new Instruction_Goto();
  togo.target=target;
  target.labelled=true;
  togo.label=++curlabel;
  last.next=togo;
  togo.prev=last;
  last=togo;
  this.lastInstruction=last;
  insnmap.put(astore,headbefore.next);
  insnmap.put(ret,togo);
  insn=headbefore.next;
  while (insn != last) {
    if (insn instanceof Instruction_branch) {
      Instruction oldtgt=((Instruction_branch)insn).target;
      Instruction newtgt=insnmap.get(oldtgt);
      if (newtgt != null) {
        ((Instruction_branch)insn).target=newtgt;
        newtgt.labelled=true;
      }
    }
 else     if (insn instanceof Instruction_Lookupswitch) {
      Instruction_Lookupswitch switchinsn=(Instruction_Lookupswitch)insn;
      Instruction newdefault=insnmap.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i < switchinsn.match_insts.length; i++) {
        Instruction newtgt=insnmap.get(switchinsn.match_insts[i]);
        if (newtgt != null) {
          switchinsn.match_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
 else     if (insn instanceof Instruction_Tableswitch) {
      Instruction_Tableswitch switchinsn=(Instruction_Tableswitch)insn;
      Instruction newdefault=insnmap.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i < switchinsn.jump_insts.length; i++) {
        Instruction newtgt=insnmap.get(switchinsn.jump_insts[i]);
        if (newtgt != null) {
          switchinsn.jump_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
    insn=insn.next;
  }
{
    Code_attribute ca=method.locate_code_attribute();
    LinkedList<exception_table_entry> newentries=new LinkedList<exception_table_entry>();
    int orig_start_of_subr=astore.next.originalIndex;
    int orig_end_of_subr=ret.originalIndex;
    for (int i=0; i < ca.exception_table_length; i++) {
      exception_table_entry etentry=ca.exception_table[i];
      int orig_start_of_trap=etentry.start_pc;
      int orig_end_of_trap=etentry.end_pc;
      if (orig_start_of_trap < orig_end_of_subr && orig_end_of_trap > orig_start_of_subr) {
        exception_table_entry newone=new exception_table_entry();
        if (orig_start_of_trap <= orig_start_of_subr) {
          newone.start_inst=headbefore.next;
        }
 else {
          Instruction ins=insnmap.get(etentry.start_inst);
          if (ins != null)           newone.start_inst=insnmap.get(etentry.start_inst);
 else           newone.start_inst=etentry.start_inst;
        }
        if (orig_end_of_trap > orig_end_of_subr) {
          newone.end_inst=null;
        }
 else {
          newone.end_inst=insnmap.get(etentry.end_inst);
        }
        newone.handler_inst=insnmap.get(etentry.handler_inst);
        if (newone.handler_inst == null)         newone.handler_inst=etentry.handler_inst;
        newentries.add(newone);
      }
      if (etentry.end_inst == null) {
        etentry.end_inst=headbefore.next;
      }
    }
    if (newentries.size() > 0) {
      ca.exception_table_length+=newentries.size();
      exception_table_entry[] newtable=new exception_table_entry[ca.exception_table_length];
      System.arraycopy(ca.exception_table,0,newtable,0,ca.exception_table.length);
      for (int i=0, j=ca.exception_table.length; i < newentries.size(); i++, j++) {
        newtable[j]=newentries.get(i);
      }
      ca.exception_table=newtable;
    }
  }
{
    Code_attribute ca=method.locate_code_attribute();
    LocalVariableTable_attribute la=ca.findLocalVariableTable();
    if (la != null) {
      LinkedList<local_variable_table_entry> newentries=new LinkedList<local_variable_table_entry>();
      int orig_start_of_subr=astore.next.originalIndex;
      int orig_end_of_subr=ret.originalIndex;
      for (int i=0; i < la.local_variable_table_length; i++) {
        local_variable_table_entry lat_entry=la.local_variable_table[i];
        int orig_start=lat_entry.start_pc;
        int orig_end=lat_entry.start_pc + lat_entry.length;
        if (orig_start < orig_end_of_subr && orig_end > orig_start_of_subr) {
          local_variable_table_entry newone=new local_variable_table_entry();
          newone.index=lat_entry.index;
          newone.name_index=lat_entry.name_index;
          newone.descriptor_index=lat_entry.descriptor_index;
          if (orig_start <= orig_start_of_subr) {
            newone.start_inst=headbefore.next;
          }
 else {
            Instruction ins=insnmap.get(lat_entry.start_inst);
            if (ins != null)             newone.start_inst=insnmap.get(lat_entry.start_inst);
 else             newone.start_inst=lat_entry.start_inst;
          }
          if (orig_end > orig_end_of_subr) {
            newone.end_inst=null;
          }
 else {
            newone.end_inst=insnmap.get(lat_entry.end_inst);
          }
          newentries.add(newone);
        }
        if (lat_entry.end_inst == null) {
          lat_entry.end_inst=headbefore.next;
        }
      }
      if (newentries.size() > 0) {
        la.local_variable_table_length+=newentries.size();
        local_variable_table_entry[] newtable=new local_variable_table_entry[la.local_variable_table_length];
        System.arraycopy(la.local_variable_table,0,newtable,0,la.local_variable_table.length);
        for (int i=0, j=la.local_variable_table.length; i < newentries.size(); i++, j++) {
          newtable[j]=newentries.get(i);
        }
        la.local_variable_table=newtable;
      }
    }
  }
  return headbefore.next;
}
