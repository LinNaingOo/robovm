{
  Set<Unit> trapsThatAreHeads=new ArraySet<Unit>();
  Unit entryPoint=(Unit)unitChain.getFirst();
  for (Iterator<Entry<Unit,Collection<ExceptionDest>>> it=unitToExceptionDests.entrySet().iterator(); it.hasNext(); ) {
    Entry<Unit,Collection<ExceptionDest>> entry=it.next();
    Unit thrower=(Unit)entry.getKey();
    List<Unit> throwersPreds=getUnexceptionalPredsOf(thrower);
    Collection<ExceptionDest> dests=entry.getValue();
    boolean alwaysAddSelfEdges=((!omitExceptingUnitEdges) || mightHaveSideEffects(thrower));
    ThrowableSet predThrowables=null;
    ThrowableSet selfThrowables=null;
    if (thrower instanceof ThrowStmt) {
      ThrowStmt throwStmt=(ThrowStmt)thrower;
      predThrowables=throwAnalysis.mightThrowImplicitly(throwStmt);
      selfThrowables=throwAnalysis.mightThrowExplicitly(throwStmt);
    }
    for (Iterator<ExceptionDest> destIt=dests.iterator(); destIt.hasNext(); ) {
      ExceptionDest dest=destIt.next();
      if (dest.getTrap() != null) {
        Unit catcher=dest.getTrap().getHandlerUnit();
        RefType trapsType=dest.getTrap().getException().getType();
        if (predThrowables == null || predThrowables.catchableAs(trapsType)) {
          if (thrower == entryPoint) {
            trapsThatAreHeads.add(catcher);
          }
          for (Iterator<Unit> p=throwersPreds.iterator(); p.hasNext(); ) {
            Unit pred=p.next();
            addEdge(unitToSuccs,unitToPreds,pred,catcher);
          }
        }
        if (alwaysAddSelfEdges || (selfThrowables != null && selfThrowables.catchableAs(trapsType))) {
          addEdge(unitToSuccs,unitToPreds,thrower,catcher);
        }
      }
    }
  }
class CFGEdge {
    Unit head;
    Unit tail;
    CFGEdge(    Unit head,    Unit tail){
      if (tail == null)       throw new RuntimeException("invalid CFGEdge(" + head.toString() + ','+ "null"+ ')');
      this.head=head;
      this.tail=tail;
    }
    public boolean equals(    Object rhs){
      if (rhs == this) {
        return true;
      }
      if (!(rhs instanceof CFGEdge)) {
        return false;
      }
      CFGEdge rhsEdge=(CFGEdge)rhs;
      return ((this.head == rhsEdge.head) && (this.tail == rhsEdge.tail));
    }
    public int hashCode(){
      int result=17;
      result=37 * result + this.head.hashCode();
      result=37 * result + this.tail.hashCode();
      return result;
    }
  }
  LinkedList<CFGEdge> workList=new LinkedList<CFGEdge>();
  for (Iterator<Trap> trapIt=body.getTraps().iterator(); trapIt.hasNext(); ) {
    Trap trap=trapIt.next();
    Unit handlerStart=trap.getHandlerUnit();
    if (mightThrowToIntraproceduralCatcher(handlerStart)) {
      List<Unit> handlerPreds=getUnexceptionalPredsOf(handlerStart);
      for (Iterator<Unit> it=handlerPreds.iterator(); it.hasNext(); ) {
        Unit pred=it.next();
        workList.addLast(new CFGEdge(pred,handlerStart));
      }
      handlerPreds=getExceptionalPredsOf(handlerStart);
      for (Iterator<Unit> it=handlerPreds.iterator(); it.hasNext(); ) {
        Unit pred=it.next();
        workList.addLast(new CFGEdge(pred,handlerStart));
      }
      if (trapsThatAreHeads.contains(handlerStart)) {
        workList.addLast(new CFGEdge(null,handlerStart));
      }
    }
  }
  while (workList.size() > 0) {
    CFGEdge edgeToThrower=workList.removeFirst();
    Unit pred=edgeToThrower.head;
    Unit thrower=edgeToThrower.tail;
    Collection<ExceptionDest> throwerDests=getExceptionDests(thrower);
    for (Iterator<ExceptionDest> i=throwerDests.iterator(); i.hasNext(); ) {
      ExceptionDest dest=i.next();
      if (dest.getTrap() != null) {
        Unit handlerStart=dest.getTrap().getHandlerUnit();
        boolean edgeAdded=false;
        if (pred == null) {
          if (!trapsThatAreHeads.contains(handlerStart)) {
            trapsThatAreHeads.add(handlerStart);
            edgeAdded=true;
          }
        }
 else {
          if (!getExceptionalSuccsOf(pred).contains(handlerStart)) {
            addEdge(unitToSuccs,unitToPreds,pred,handlerStart);
            edgeAdded=true;
          }
        }
        if (edgeAdded && mightThrowToIntraproceduralCatcher(handlerStart)) {
          workList.addLast(new CFGEdge(pred,handlerStart));
        }
      }
    }
  }
  return trapsThatAreHeads;
}
