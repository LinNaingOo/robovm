{
  int outRemaining=out.remaining();
  int pos=in.position();
  int limit=in.limit();
  try {
    while (pos < limit) {
      if (endian == UNKNOWN) {
        endian=getDefaultEndian();
        if (endian == ANY) {
          if (outRemaining < 2) {
            endian=UNKNOWN;
            return CoderResult.OVERFLOW;
          }
          endian=BIG;
          out.put((byte)0xFE);
          out.put((byte)0xFF);
          outRemaining-=2;
        }
      }
      if (outRemaining == 0) {
        return CoderResult.OVERFLOW;
      }
      int jchar=(in.get() & 0xFFFF);
      if (jchar >= 0xD800 && jchar <= 0xDFFF) {
        if (limit <= pos + 1) {
          return CoderResult.UNDERFLOW;
        }
        if (outRemaining < 4) {
          return CoderResult.OVERFLOW;
        }
        if (jchar >= 0xDC00) {
          return CoderResult.malformedForLength(1);
        }
        int jchar2=(in.get() & 0xFFFF);
        if (jchar2 < 0xDC00) {
          return CoderResult.malformedForLength(1);
        }
        if (endian == BIG) {
          out.put((byte)((jchar >> 8) & 0xFF));
          out.put((byte)(jchar & 0xFF));
          out.put((byte)((jchar2 >> 8) & 0xFF));
          out.put((byte)(jchar2 & 0xFF));
        }
 else {
          out.put((byte)(jchar & 0xFF));
          out.put((byte)((jchar >> 8) & 0xFF));
          out.put((byte)(jchar2 & 0xFF));
          out.put((byte)((jchar2 >> 8) & 0xFF));
        }
        outRemaining-=4;
        pos++;
      }
 else {
        if (outRemaining < 2) {
          return CoderResult.OVERFLOW;
        }
        if (endian == BIG) {
          out.put((byte)((jchar >> 8) & 0xFF));
          out.put((byte)(jchar & 0xFF));
        }
 else {
          out.put((byte)(jchar & 0xFF));
          out.put((byte)((jchar >> 8) & 0xFF));
        }
        outRemaining-=2;
      }
      pos++;
    }
    return CoderResult.UNDERFLOW;
  }
  finally {
    in.position(pos);
  }
}
