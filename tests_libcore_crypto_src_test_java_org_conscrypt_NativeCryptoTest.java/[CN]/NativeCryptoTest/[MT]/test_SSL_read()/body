{
  try {
    NativeCrypto.SSL_read(NULL,null,null,null,0,0,0);
    fail();
  }
 catch (  NullPointerException expected) {
  }
{
    long c=NativeCrypto.SSL_CTX_new();
    long s=NativeCrypto.SSL_new(c);
    try {
      NativeCrypto.SSL_read(s,null,DUMMY_CB,null,0,0,0);
      fail();
    }
 catch (    NullPointerException expected) {
    }
    NativeCrypto.SSL_free(s);
    NativeCrypto.SSL_CTX_free(c);
  }
{
    long c=NativeCrypto.SSL_CTX_new();
    long s=NativeCrypto.SSL_new(c);
    try {
      NativeCrypto.SSL_read(s,INVALID_FD,null,null,0,0,0);
      fail();
    }
 catch (    NullPointerException expected) {
    }
    NativeCrypto.SSL_free(s);
    NativeCrypto.SSL_CTX_free(c);
  }
{
    long c=NativeCrypto.SSL_CTX_new();
    long s=NativeCrypto.SSL_new(c);
    try {
      NativeCrypto.SSL_read(s,INVALID_FD,DUMMY_CB,null,0,0,0);
      fail();
    }
 catch (    NullPointerException expected) {
    }
    NativeCrypto.SSL_free(s);
    NativeCrypto.SSL_CTX_free(c);
  }
{
    long c=NativeCrypto.SSL_CTX_new();
    long s=NativeCrypto.SSL_new(c);
    try {
      NativeCrypto.SSL_read(s,INVALID_FD,DUMMY_CB,new byte[1],0,1,0);
      fail();
    }
 catch (    SSLException expected) {
    }
    NativeCrypto.SSL_free(s);
    NativeCrypto.SSL_CTX_free(c);
  }
  final ServerSocket listener=new ServerSocket(0);
{
    Hooks cHooks=new Hooks(){
      @Override public void afterHandshake(      long session,      long s,      long c,      Socket sock,      FileDescriptor fd,      SSLHandshakeCallbacks callback) throws Exception {
        byte[] in=new byte[256];
        assertEquals(BYTES.length,NativeCrypto.SSL_read(s,fd,callback,in,0,BYTES.length,0));
        for (int i=0; i < BYTES.length; i++) {
          assertEquals(BYTES[i],in[i]);
        }
        super.afterHandshake(session,s,c,sock,fd,callback);
      }
    }
;
    Hooks sHooks=new ServerHooks(getServerPrivateKey(),getServerCertificates()){
      @Override public void afterHandshake(      long session,      long s,      long c,      Socket sock,      FileDescriptor fd,      SSLHandshakeCallbacks callback) throws Exception {
        NativeCrypto.SSL_write(s,fd,callback,BYTES,0,BYTES.length,0);
        super.afterHandshake(session,s,c,sock,fd,callback);
      }
    }
;
    Future<TestSSLHandshakeCallbacks> client=handshake(listener,0,true,cHooks,null,null);
    Future<TestSSLHandshakeCallbacks> server=handshake(listener,0,false,sHooks,null,null);
    client.get(TIMEOUT_SECONDS,TimeUnit.SECONDS);
    server.get(TIMEOUT_SECONDS,TimeUnit.SECONDS);
  }
  try {
    Hooks cHooks=new Hooks(){
      @Override public void afterHandshake(      long session,      long s,      long c,      Socket sock,      FileDescriptor fd,      SSLHandshakeCallbacks callback) throws Exception {
        NativeCrypto.SSL_read(s,fd,callback,new byte[1],0,1,1);
        fail();
      }
    }
;
    Hooks sHooks=new ServerHooks(getServerPrivateKey(),getServerCertificates()){
      @Override public void afterHandshake(      long session,      long s,      long c,      Socket sock,      FileDescriptor fd,      SSLHandshakeCallbacks callback) throws Exception {
        NativeCrypto.SSL_read(s,fd,callback,new byte[1],0,1,0);
        super.afterHandshake(session,s,c,sock,fd,callback);
      }
    }
;
    Future<TestSSLHandshakeCallbacks> client=handshake(listener,0,true,cHooks,null,null);
    Future<TestSSLHandshakeCallbacks> server=handshake(listener,0,false,sHooks,null,null);
    client.get(TIMEOUT_SECONDS,TimeUnit.SECONDS);
    fail();
  }
 catch (  ExecutionException expected) {
    assertEquals(SocketTimeoutException.class,expected.getCause().getClass());
  }
}
