{
  tags=new byte[count];
  offsets=new int[count];
  offsets[0]=pos();
  for (int c=1; c < count; c++) {
    int tag=read1();
    tags[c]=(byte)tag;
    offsets[c]=pos();
switch (tag) {
case CONSTANT_String:
case CONSTANT_Class:
      skip(2);
    break;
case CONSTANT_Fieldref:
case CONSTANT_Methodref:
case CONSTANT_InterfaceMethodref:
case CONSTANT_NameAndType:
case CONSTANT_Integer:
case CONSTANT_Float:
  skip(4);
break;
case CONSTANT_Double:
case CONSTANT_Long:
skip(8);
c++;
break;
case CONSTANT_Utf8:
int len=read2u();
skip(len);
break;
case CONSTANT_Unicode:
throw new ClassFormatError("unicode not supported");
default :
throw new ClassFormatError("illegal tag " + tag);
}
}
handleConstantPool(bytes,tags,offsets,count);
}
