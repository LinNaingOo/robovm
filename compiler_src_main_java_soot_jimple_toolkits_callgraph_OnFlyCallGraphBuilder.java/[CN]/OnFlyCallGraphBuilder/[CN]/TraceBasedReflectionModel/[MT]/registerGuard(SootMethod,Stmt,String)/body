{
  guards.add(new Guard(container,stmt,string));
  if (options.verbose()) {
    G.v().out.println("Incomplete trace file: Class.forName() is called in method '" + container + "' but trace contains no information about the receiver class of this call.");
    if (options.guards().equals("ignore")) {
      G.v().out.println("Guarding strategy is set to 'ignore'. Will ignore this problem.");
    }
 else     if (options.guards().equals("print")) {
      G.v().out.println("Guarding strategy is set to 'print'. " + "Program will print a stack trace if this location is reached during execution.");
    }
 else     if (options.guards().equals("throw")) {
      G.v().out.println("Guarding strategy is set to 'throw'. Program will throw an " + "Error if this location is reached during execution.");
    }
 else {
      throw new RuntimeException("Invalid value for phase option (guarding): " + options.guards());
    }
  }
  if (!registeredTransformation) {
    registeredTransformation=true;
    PackManager.v().getPack("wjap").add(new Transform("wjap.guards",new SceneTransformer(){
      @Override protected void internalTransform(      String phaseName,      Map options){
        for (        Guard g : guards) {
          insertGuard(g);
        }
      }
    }
));
    PhaseOptions.v().setPhaseOption("wjap.guards","enabled");
  }
}
