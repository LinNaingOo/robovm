{
  StmtBody body=(StmtBody)b;
  if (Options.v().verbose())   G.v().out.println("[" + body.getMethod().getName() + "] Folding unconditional branches...");
  if (numFound == null) {
    numFound=new int[JUMPOPT_TYPES + 1];
    numFixed=new int[JUMPOPT_TYPES + 1];
  }
  for (int i=0; i <= JUMPOPT_TYPES; i++) {
    numFound[i]=0;
    numFixed[i]=0;
  }
  Chain units=body.getUnits();
  stmtMap=new HashMap<Stmt,Stmt>();
  Iterator stmtIt=units.iterator();
  Stmt stmt, target, newTarget;
  while (stmtIt.hasNext()) {
    stmt=(Stmt)stmtIt.next();
    if (stmt instanceof GotoStmt) {
      target=(Stmt)((GotoStmt)stmt).getTarget();
      if (stmtIt.hasNext()) {
        if (units.getSuccOf(stmt) == target) {
          stmtIt.remove();
          updateCounters(6,true);
        }
      }
      if (target instanceof GotoStmt) {
        newTarget=getFinalTarget(target);
        if (newTarget == null)         newTarget=stmt;
        ((GotoStmt)stmt).setTarget(newTarget);
        updateCounters(1,true);
      }
 else       if (target instanceof IfStmt) {
        updateCounters(3,false);
      }
    }
 else     if (stmt instanceof IfStmt) {
      target=((IfStmt)stmt).getTarget();
      if (target instanceof GotoStmt) {
        newTarget=getFinalTarget(target);
        if (newTarget == null)         newTarget=stmt;
        ((IfStmt)stmt).setTarget(newTarget);
        updateCounters(2,true);
      }
 else       if (target instanceof IfStmt) {
        updateCounters(4,false);
      }
    }
  }
  if (Options.v().verbose())   G.v().out.println("[" + body.getMethod().getName() + "]     "+ numFixed[0]+ " of "+ numFound[0]+ " branches folded.");
}
