{
  classForNameReceivers=new LinkedHashMap<SootMethod,Set<String>>();
  classNewInstanceReceivers=new LinkedHashMap<SootMethod,Set<String>>();
  constructorNewInstanceReceivers=new LinkedHashMap<SootMethod,Set<String>>();
  methodInvokeReceivers=new LinkedHashMap<SootMethod,Set<String>>();
  fieldSetReceivers=new LinkedHashMap<SootMethod,Set<String>>();
  fieldGetReceivers=new LinkedHashMap<SootMethod,Set<String>>();
  if (logFile == null) {
    throw new InternalError("Trace based refection model enabled but no trace file given!?");
  }
 else {
    try {
      BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(logFile)));
      String line;
      int lines=0;
      Set<String> ignoredKinds=new HashSet<String>();
      while ((line=reader.readLine()) != null) {
        if (line.length() == 0)         continue;
        String[] portions=line.split(";",-1);
        String kind=portions[0];
        String target=portions[1];
        String source=portions[2];
        int lineNumber=portions[3].length() == 0 ? -1 : Integer.parseInt(portions[3]);
        Set<SootMethod> possibleSourceMethods=inferSource(source,lineNumber);
        for (        SootMethod sourceMethod : possibleSourceMethods) {
          if (kind.equals("Class.forName")) {
            Set<String> receiverNames;
            if ((receiverNames=classForNameReceivers.get(sourceMethod)) == null) {
              classForNameReceivers.put(sourceMethod,receiverNames=new LinkedHashSet<String>());
            }
            receiverNames.add(target);
          }
 else           if (kind.equals("Class.newInstance")) {
            Set<String> receiverNames;
            if ((receiverNames=classNewInstanceReceivers.get(sourceMethod)) == null) {
              classNewInstanceReceivers.put(sourceMethod,receiverNames=new LinkedHashSet<String>());
            }
            receiverNames.add(target);
          }
 else           if (kind.equals("Method.invoke")) {
            if (!Scene.v().containsMethod(target)) {
              throw new RuntimeException("Unknown method for signature: " + target);
            }
            Set<String> receiverNames;
            if ((receiverNames=methodInvokeReceivers.get(sourceMethod)) == null) {
              methodInvokeReceivers.put(sourceMethod,receiverNames=new LinkedHashSet<String>());
            }
            receiverNames.add(target);
          }
 else           if (kind.equals("Constructor.newInstance")) {
            if (!Scene.v().containsMethod(target)) {
              throw new RuntimeException("Unknown method for signature: " + target);
            }
            Set<String> receiverNames;
            if ((receiverNames=constructorNewInstanceReceivers.get(sourceMethod)) == null) {
              constructorNewInstanceReceivers.put(sourceMethod,receiverNames=new LinkedHashSet<String>());
            }
            receiverNames.add(target);
          }
 else           if (kind.equals("Field.set*")) {
            if (!Scene.v().containsField(target)) {
              throw new RuntimeException("Unknown method for signature: " + target);
            }
            Set<String> receiverNames;
            if ((receiverNames=fieldSetReceivers.get(sourceMethod)) == null) {
              fieldSetReceivers.put(sourceMethod,receiverNames=new LinkedHashSet<String>());
            }
            receiverNames.add(target);
          }
 else           if (kind.equals("Field.get*")) {
            if (!Scene.v().containsField(target)) {
              throw new RuntimeException("Unknown method for signature: " + target);
            }
            Set<String> receiverNames;
            if ((receiverNames=fieldGetReceivers.get(sourceMethod)) == null) {
              fieldGetReceivers.put(sourceMethod,receiverNames=new LinkedHashSet<String>());
            }
            receiverNames.add(target);
          }
 else {
            ignoredKinds.add(kind);
          }
        }
        lines++;
      }
      if (!ignoredKinds.isEmpty()) {
        G.v().out.println("Encountered reflective calls entries of the following kinds that\n" + "cannot currently be handled:");
        for (        String kind : ignoredKinds) {
          G.v().out.println(kind);
        }
      }
    }
 catch (    FileNotFoundException e) {
      throw new RuntimeException("Trace file not found.",e);
    }
catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}
