{
  InetAddress address=null;
  if (Inet6Util.isValidIPV4Address(ipAddressString)) {
    byte[] byteAddress=new byte[4];
    String[] parts=ipAddressString.split("\\.");
    int length=parts.length;
    if (length == 1) {
      long value=Long.parseLong(parts[0]);
      for (int i=0; i < 4; i++) {
        byteAddress[i]=(byte)(value >> ((3 - i) * 8));
      }
    }
 else {
      for (int i=0; i < length; i++) {
        byteAddress[i]=(byte)Integer.parseInt(parts[i]);
      }
    }
    if (length == 2) {
      byteAddress[3]=byteAddress[1];
      byteAddress[1]=0;
    }
    if (length == 3) {
      byteAddress[3]=byteAddress[2];
      byteAddress[2]=0;
    }
    address=new Inet4Address(byteAddress);
  }
 else {
    if (ipAddressString.charAt(0) == '[') {
      ipAddressString=ipAddressString.substring(1,ipAddressString.length() - 1);
    }
    StringTokenizer tokenizer=new StringTokenizer(ipAddressString,":.%",true);
    ArrayList<String> hexStrings=new ArrayList<String>();
    ArrayList<String> decStrings=new ArrayList<String>();
    String scopeString=null;
    String token="";
    String prevToken="";
    String prevPrevToken="";
    int doubleColonIndex=-1;
    while (tokenizer.hasMoreTokens()) {
      prevPrevToken=prevToken;
      prevToken=token;
      token=tokenizer.nextToken();
      if (token.equals(":")) {
        if (prevToken.equals(":")) {
          doubleColonIndex=hexStrings.size();
        }
 else         if (!prevToken.equals("")) {
          hexStrings.add(prevToken);
        }
      }
 else       if (token.equals(".")) {
        decStrings.add(prevToken);
      }
 else       if (token.equals("%")) {
        if (!prevToken.equals(":") && !prevToken.equals(".")) {
          if (prevPrevToken.equals(":")) {
            hexStrings.add(prevToken);
          }
 else           if (prevPrevToken.equals(".")) {
            decStrings.add(prevToken);
          }
        }
        StringBuilder buf=new StringBuilder();
        while (tokenizer.hasMoreTokens()) {
          buf.append(tokenizer.nextToken());
        }
        scopeString=buf.toString();
      }
    }
    if (prevToken.equals(":")) {
      if (token.equals(":")) {
        doubleColonIndex=hexStrings.size();
      }
 else {
        hexStrings.add(token);
      }
    }
 else     if (prevToken.equals(".")) {
      decStrings.add(token);
    }
    int hexStringsLength=8;
    if (decStrings.size() > 0) {
      hexStringsLength-=2;
    }
    if (doubleColonIndex != -1) {
      int numberToInsert=hexStringsLength - hexStrings.size();
      for (int i=0; i < numberToInsert; i++) {
        hexStrings.add(doubleColonIndex,"0");
      }
    }
    byte ipByteArray[]=new byte[16];
    for (int i=0; i < hexStrings.size(); i++) {
      Inet6Util.convertToBytes(hexStrings.get(i),ipByteArray,i * 2);
    }
    for (int i=0; i < decStrings.size(); i++) {
      ipByteArray[i + 12]=(byte)(Integer.parseInt(decStrings.get(i)) & 255);
    }
    boolean ipV4=true;
    for (int i=0; i < 10; i++) {
      if (ipByteArray[i] != 0) {
        ipV4=false;
        break;
      }
    }
    if (ipByteArray[10] != -1 || ipByteArray[11] != -1) {
      ipV4=false;
    }
    if (ipV4) {
      byte ipv4ByteArray[]=new byte[4];
      for (int i=0; i < 4; i++) {
        ipv4ByteArray[i]=ipByteArray[i + 12];
      }
      address=InetAddress.getByAddress(ipv4ByteArray);
    }
 else {
      int scopeId=0;
      if (scopeString != null) {
        try {
          scopeId=Integer.parseInt(scopeString);
        }
 catch (        Exception e) {
        }
      }
      address=InetAddress.getByAddress(ipByteArray,scopeId);
    }
  }
  return address;
}
