{
  MHGDominatorTree dom=new MHGDominatorTree(new MHGDominatorsFinder<Unit>(this));
  MHGDominatorTree pdom=new MHGDominatorTree(new MHGPostDominatorsFinder(this));
  Hashtable<Unit,Unit> x2mergePoint=new Hashtable<Unit,Unit>();
  List<Unit> tails=this.getTails();
  TailsLoop:   for (Iterator<Unit> itr=tails.iterator(); itr.hasNext(); ) {
    Unit tail=itr.next();
    if (!(tail instanceof ThrowStmt))     continue;
    DominatorNode x=dom.getDode(tail);
    DominatorNode parentOfX=dom.getParentOf(x);
    Object xgode=x.getGode();
    DominatorNode xpdomDode=pdom.getDode(xgode);
    Object parentXGode=parentOfX.getGode();
    DominatorNode parentpdomDode=pdom.getDode(parentXGode);
    while (pdom.isDominatorOf(xpdomDode,parentpdomDode)) {
      x=parentOfX;
      parentOfX=dom.getParentOf(x);
      if (parentOfX == null)       break;
      xgode=x.getGode();
      xpdomDode=pdom.getDode(xgode);
      parentXGode=parentOfX.getGode();
      parentpdomDode=pdom.getDode(parentXGode);
    }
    if (parentOfX != null)     x=parentOfX;
    xgode=x.getGode();
    xpdomDode=pdom.getDode(xgode);
    Unit mergePoint=null;
    if (x2mergePoint.containsKey(xgode))     mergePoint=x2mergePoint.get(xgode);
 else {
      List<DominatorNode> domChilds=dom.getChildrenOf(x);
      Object child1god=null;
      Object child2god=null;
      for (Iterator<DominatorNode> domItr=domChilds.iterator(); domItr.hasNext(); ) {
        DominatorNode child=domItr.next();
        Object childGode=child.getGode();
        DominatorNode childpdomDode=pdom.getDode(childGode);
        List<Unit> path=this.getExtendedBasicBlockPathBetween((Unit)childGode,tail);
        if (!(path == null || path.size() == 0))         continue;
        if (pdom.isDominatorOf(childpdomDode,xpdomDode)) {
          mergePoint=(Unit)child.getGode();
          break;
        }
        if (child1god == null)         child1god=childGode;
 else         if (child2god == null)         child2god=childGode;
      }
      if (mergePoint == null) {
        if (child1god != null && child2god != null) {
          DominatorNode child1=pdom.getDode(child1god);
          DominatorNode child2=pdom.getDode(child2god);
          DominatorNode comParent=child1.getParent();
          while (comParent != null) {
            if (pdom.isDominatorOf(comParent,child2)) {
              mergePoint=(Unit)comParent.getGode();
              break;
            }
            comParent=comParent.getParent();
          }
        }
 else         if (child1god != null || child2god != null) {
          DominatorNode y=null;
          if (child1god != null)           y=pdom.getDode(child1god);
 else           if (child2god != null)           y=pdom.getDode(child2god);
          DominatorNode initialY=dom.getDode(y.getGode());
          DominatorNode yDodeInDom=initialY;
          while (dom.isDominatorOf(x,yDodeInDom)) {
            y=y.getParent();
            if (y == null) {
              break;
            }
            yDodeInDom=dom.getDode(y.getGode());
          }
          if (y != null)           mergePoint=(Unit)y.getGode();
 else           mergePoint=(Unit)initialY.getGode();
        }
      }
      if (mergePoint == null) {
        List<Unit> xSucc=this.unitToSuccs.get(x.getGode());
        for (Iterator<Unit> uItr=xSucc.iterator(); uItr.hasNext(); ) {
          Unit u=uItr.next();
          if (dom.isDominatorOf(dom.getDode(u),dom.getDode(tail)))           continue;
          DominatorNode y=pdom.getDode(u);
          while (dom.isDominatorOf(x,y)) {
            y=y.getParent();
            if (y == null) {
              continue TailsLoop;
            }
          }
          mergePoint=(Unit)y.getGode();
          break;
        }
      }
 else       if (dom.isDominatorOf(dom.getDode(mergePoint),dom.getDode(tail)))       continue TailsLoop;
      if (mergePoint == null)       throw new RuntimeException("This should not have happened!");
      x2mergePoint.put((Unit)xgode,mergePoint);
    }
    if (!this.unitToSuccs.containsKey(tail))     this.unitToSuccs.put(tail,new ArrayList<Unit>());
    List<Unit> throwSuccs=this.unitToSuccs.get(tail);
    throwSuccs.add(mergePoint);
    List<Unit> mergePreds=this.unitToPreds.get(mergePoint);
    mergePreds.add(tail);
  }
}
