{
  int bbRemaining=bb.remaining();
  if (bbRemaining == 0) {
    return CoderResult.UNDERFLOW;
  }
  int cbRemaining=cb.remaining();
  boolean cbHasArray=cb.hasArray();
  if (cbHasArray) {
    if (bb.hasArray()) {
      int rem=bbRemaining;
      rem=cbRemaining >= rem ? rem : cbRemaining;
      byte[] arr=bb.array();
      char[] cArr=cb.array();
      int bStart=bb.position();
      int cStart=cb.position();
      int i;
      for (i=bStart; i < bStart + rem; i++) {
        cArr[cStart++]=(char)((int)arr[i] & 0xFF);
      }
      bb.position(i);
      cb.position(cStart);
      if (rem == cbRemaining && bb.hasRemaining()) {
        return CoderResult.OVERFLOW;
      }
      return CoderResult.UNDERFLOW;
    }
 else     if (CharsetProviderImpl.hasLoadedNatives() && bb.isDirect()) {
      int toProceed=bbRemaining;
      boolean throwOverflow=false;
      int cbPos=cb.position();
      int bbPos=bb.position();
      if (cbRemaining < toProceed) {
        toProceed=cbRemaining;
        throwOverflow=true;
      }
      int res=nDecode(cb.array(),cb.arrayOffset() + cbPos,toProceed,AddressUtil.getDirectBufferAddress(bb),bbPos);
      cb.position(cbPos + res);
      bb.position(bbPos + res);
      if (throwOverflow) {
        return CoderResult.OVERFLOW;
      }
      return CoderResult.UNDERFLOW;
    }
  }
  int rem=bbRemaining;
  rem=cbRemaining >= rem ? rem : cbRemaining;
  byte[] arr=new byte[rem];
  bb.get(arr);
  char[] cArr=new char[rem];
  for (int i=0; i < rem; i++) {
    cArr[i]=(char)((int)arr[i] & 0xFF);
  }
  cb.put(cArr);
  if (cb.remaining() == 0) {
    return CoderResult.OVERFLOW;
  }
  return CoderResult.UNDERFLOW;
}
