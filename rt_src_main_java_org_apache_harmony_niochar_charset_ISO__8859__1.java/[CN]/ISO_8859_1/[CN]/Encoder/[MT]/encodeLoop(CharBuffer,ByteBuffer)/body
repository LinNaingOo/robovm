{
  int cbRemaining=cb.remaining();
  if (cbRemaining == 0) {
    return CoderResult.UNDERFLOW;
  }
  int bbRemaining=bb.remaining();
  boolean cbHasArray=cb.hasArray();
  boolean bbHasArray=bb.hasArray();
  if (cbHasArray) {
    if (bbHasArray) {
      byte[] byteArr=bb.array();
      char[] charArr=cb.array();
      int byteArrStart=bb.position();
      int rem=bbRemaining <= cbRemaining ? bbRemaining : cbRemaining;
      int cbPos=cb.position();
      int x;
      int jchar=0;
      for (x=cbPos; x < cbPos + rem; x++) {
        jchar=(int)charArr[x];
        if (jchar <= 0xFF) {
          byteArr[byteArrStart++]=(byte)jchar;
        }
 else {
          break;
        }
      }
      bb.position(byteArrStart);
      cb.position(x);
      if (x == cbPos + rem) {
        if (rem == bbRemaining && cb.hasRemaining()) {
          return CoderResult.OVERFLOW;
        }
        return CoderResult.UNDERFLOW;
      }
      if (jchar >= 0xD800 && jchar <= 0xDFFF) {
        if (x + 1 < cb.limit()) {
          char c1=charArr[x + 1];
          if (c1 >= 0xD800 && c1 <= 0xDFFF) {
            return CoderResult.unmappableForLength(2);
          }
        }
 else {
          return CoderResult.UNDERFLOW;
        }
        return CoderResult.malformedForLength(1);
      }
      return CoderResult.unmappableForLength(1);
    }
 else     if (CharsetProviderImpl.hasLoadedNatives() && bb.isDirect()) {
      int toProceed=cbRemaining;
      boolean throwOverflow=false;
      int cbPos=cb.position();
      int bbPos=bb.position();
      if (bbRemaining < toProceed) {
        toProceed=bbRemaining;
        throwOverflow=true;
      }
      int[] res={toProceed,0};
      nEncode(AddressUtil.getDirectBufferAddress(bb),bbPos,cb.array(),cb.arrayOffset() + cbPos,res);
      if (res[0] <= 0) {
        bb.position(bbPos - res[0]);
        cb.position(cbPos - res[0]);
        if (res[1] != 0) {
          if (res[1] < 0) {
            return CoderResult.malformedForLength(-res[1]);
          }
 else {
            return CoderResult.unmappableForLength(res[1]);
          }
        }
      }
 else {
        bb.position(bbPos + res[0]);
        cb.position(cbPos + res[0]);
        if (throwOverflow) {
          return CoderResult.OVERFLOW;
        }
      }
      return CoderResult.UNDERFLOW;
    }
  }
  while (cb.hasRemaining()) {
    if (bbRemaining == 0) {
      return CoderResult.OVERFLOW;
    }
    char c=cb.get();
    if (c > (char)0x00FF) {
      if (c >= 0xD800 && c <= 0xDFFF) {
        if (cb.hasRemaining()) {
          char c1=cb.get();
          if (c1 >= 0xD800 && c1 <= 0xDFFF) {
            cb.position(cb.position() - 2);
            return CoderResult.unmappableForLength(2);
          }
 else {
            cb.position(cb.position() - 1);
          }
        }
 else {
          cb.position(cb.position() - 1);
          return CoderResult.UNDERFLOW;
        }
        cb.position(cb.position() - 1);
        return CoderResult.malformedForLength(1);
      }
      cb.position(cb.position() - 1);
      return CoderResult.unmappableForLength(1);
    }
 else {
      bb.put((byte)c);
      bbRemaining--;
    }
  }
  return CoderResult.UNDERFLOW;
}
