{
  int counter=0;
  Iterator localsIt=b.getLocals().iterator();
  HashSet<String> localNames=new HashSet<String>(b.getLocals().size());
  while (localsIt.hasNext()) {
    localNames.add(((Local)localsIt.next()).getName());
  }
  SideEffectTester sideEffect;
  if (Scene.v().hasCallGraph() && !PhaseOptions.getBoolean(options,"naive-side-effect")) {
    sideEffect=new PASideEffectTester();
  }
 else {
    sideEffect=new NaiveSideEffectTester();
  }
  sideEffect.newMethod(b.getMethod());
  if (Options.v().verbose())   G.v().out.println("[" + b.getMethod().getName() + "]     Eliminating common subexpressions "+ (sideEffect instanceof NaiveSideEffectTester ? "(naively)" : "")+ "...");
  AvailableExpressions ae=new FastAvailableExpressions(b,sideEffect);
  Chain units=b.getUnits();
  Iterator unitsIt=units.snapshotIterator();
  while (unitsIt.hasNext()) {
    Stmt s=(Stmt)unitsIt.next();
    if (s instanceof AssignStmt) {
      Chain availExprs=ae.getAvailableEquivsBefore(s);
      Value v=((AssignStmt)s).getRightOp();
      EquivalentValue ev=new EquivalentValue(v);
      if (availExprs.contains(ev)) {
        List availPairs=ae.getAvailablePairsBefore(s);
        Iterator availIt=availPairs.iterator();
        while (availIt.hasNext()) {
          UnitValueBoxPair up=(UnitValueBoxPair)availIt.next();
          if (up.getValueBox().getValue().equivTo(v)) {
            String newName="$cseTmp" + counter;
            counter++;
            while (localNames.contains(newName)) {
              newName="$cseTmp" + counter;
              counter++;
            }
            Local l=Jimple.v().newLocal(newName,Type.toMachineType(v.getType()));
            b.getLocals().add(l);
            AssignStmt origCalc=(AssignStmt)up.getUnit();
            Value origLHS=origCalc.getLeftOp();
            origCalc.setLeftOp(l);
            Unit copier=Jimple.v().newAssignStmt(origLHS,l);
            units.insertAfter(copier,origCalc);
            ((AssignStmt)s).setRightOp(l);
            copier.addTag(new StringTag("Common sub-expression"));
            s.addTag(new StringTag("Common sub-expression"));
          }
        }
      }
    }
  }
  if (Options.v().verbose())   G.v().out.println("[" + b.getMethod().getName() + "]     Eliminating common subexpressions done!");
}
